##/*
##
##   (c) Copyright, Real-Time Innovations, Inc. 2001.  All rights reserved.
##   No duplications, whole or partial, manual or electronic, may be made
##   without prior written permission.  Any such copies, or
##   revisions thereof, must display this notice unaltered.
##   This code contains trade secrets of Real-Time Innovations, Inc.
##
##modification history:
##---------------------
##2.2,04jun16,fmm Casting to (const ${member.nativeTypeFQName}*) to avoid compilation 
##                 warnings when using arrays. 
##2.3,02feb16, ajm CODEGENII-462 Warning when using -Wunused-parameter
##2.0,13nov15,ajm CODEGENII-501 Setting the option to disable must understand for interlanguage
## iteroperability 
##2.0,24mar15, CODEGENII-433 Incorrect code generation for a mutable struct that inherits
## from a struct with key
##2.0,25feb15,acr CORE-6269: Use PRES_TYPEPLUGIN_CPP_LANG for C++ plugins
##2.0,05feb15,ajm CODEGENII-426 Fixing warning
##2.0,18sep14,ajm CODEGENII-364 and CODEGENII-365 Unbounded sequence and string in C/C++
##2.2.0,08sep14,ajm CODEGENII-359 Add APIs to serialize a sample to a CDR buffer and to 
## deserialize from a CDR buffer##2.0,30oct13,ajm CODEGENII-147 removing warnings
##2.0,29oct13,ajm CODEGENII-143 fixing nddsgen1 issues CODEGEN-620 CODEGEN-624
##2.0,12sep13,ajm CODEGENII-143 and CODEGEN-622 Enum as last field of a type
##2.0,12sep13,ajm CODEGENII-92: Support for optional members
##10a,10jun13,ajm CODEGENII-109 adding envMap and constructMapList variables
##10a,25mar13,ajm Adding support for enums and inheritance in .Net. We do check now
## it we are working with namespaces because we introduce always the module in the list of nodes
##10a,08mar13, ajm CODEGENII-30: Code reviews
##10a,01mar13, ajm CODEGENII-59: Updating to generate XTypes Mutable as in IN-Branch
##10a,16jan13, ajm RRTIDDSGEN-52 Renaming variables and functions for the codereview
##10a,13dec12, ajm RRTIDDSGEN-53 Support for XTypes (extensible and final)
##10a,4dec12, ajm Refactoring of the code and variable names.
##10a,8nov12, ajm  RRTIDDSGEN-34 support for the copy directives and resolve-name
##10a,25oct12, ajm Refactorizing code and variable names.
##10a,10oct12, ajm Upgrade to Bigpine.Formatting and commenting
##10a,04ene11, ajm Upgrading to Lola (code in C)
##10a,07nov11, ajm Refactoring code
##10a,21oct11,ajm Adding a return at the end of the file
##10a,17oct11,ajm Fixing a bug with enums and c++ namespaces
##10a,10oct11,ajm Adding union support
##10a,30sep11,ajm Adding noTypeCode option support
##10a,29sep11,ajm adding forward declaration and namespace support 
##10a,26sep11,ajm adding enum support 
##10a,22sep11,ajm Fixing a bug
##10a,22sep11,ajm adding valuetypes support
##10a,15sep11,ajm Fixing more typedef issues
##10a,14sep11,ajm Refactor typedef
##10a,2sep11,ajm Refactoring using a unique list for all elements(typedefs, structs and const)
##10a,2sep11,jmt Adding typedef support for sequences and arrays of sequences
##10a,01se11,jmt Adding typedef support for primitive types and typedef arrays
##10a,29ag11,ajm Fixing macros consistency by adding the missing parameters
##10a,29ag11,ajm Refactor of variables and cleaning loops 
##10a,19ag11,ajm Refactorizing and cleaning the templates code.
##10a,17ag11,ajm Adding //@key
##10a,12ag11,jmt Adding functionality for C++
##10a,11ag11,ajm Refactorizing the templates code.
##           ajm Adding variable $nativeFQName
##10a,10ag11,ajm Adding functionality for arrays
##10a,09ag11,jmt Fixing tabulations and length of the lines
##10a,08ag11,ajm Fixing an error in the template (it includes now the plugin file header intead the type file header file)
##10a,08ag11,ajm Fixing the bug for a struct without a module
##10a,05ag11,jmt Adding all the basic type and testing them
##10a,04ag11,ajm adding modification history header 
##10a,03ag11,ajm created 
##-----------------------------------------------------------------
##               
##             Template for the TypePluginBody C file
## 
##------------------------------------------------------------------
##------------------------------------------------------------------
## Structure:
##
## 
## To use this template, the structure provided from the main program
## to the context of the Velocity template must be as indicated here:
##
## The context will be feed by a list of the structs ($constructMapList) defined in the 
## IDL file. Each of the structs will have the following mandatory fields:
##
## $packageName (the path of all the modules separated by a .)
## $nodeName (the name of the struct)
## $memberFieldMapList (will be a list of all the members inside the struct)
## $memberFieldMapList must contain the followin fields:
##   name (the name of the field)
##   typeFQName (the IDL type of the variable)
##   basic (boolean, it indicates if it is a basic or non basic type)
##---------------------------------------------------------------------
##---------------------------------------------------------------------

/*
  WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.

  This file was generated from ${envMap.idlFileName}.idl
  using RTI Code Generator (rtiddsgen) version ${envMap.codegenVersion}.
  The rtiddsgen tool is part of the RTI Connext DDS distribution.
  For more information, type 'rtiddsgen -help' at a command shell
  or consult the Code Generator User's Manual.
*/


${envMap.POUND_CHAR}include <string.h>

#if(!$userVarList.noEndpointBuild)
#*--*##if($envMap.language.equals("Cpp"))
${envMap.POUND_CHAR}ifndef ndds_cpp_h
  ${envMap.POUND_CHAR}include "ndds/ndds_cpp.h"
${envMap.POUND_CHAR}endif
#*--*##else
${envMap.POUND_CHAR}ifndef ndds_c_h
  ${envMap.POUND_CHAR}include "ndds/ndds_c.h"
${envMap.POUND_CHAR}endif
#*--*##end
#end

${envMap.POUND_CHAR}ifndef osapi_type_h
  ${envMap.POUND_CHAR}include "osapi/osapi_type.h"
${envMap.POUND_CHAR}endif
${envMap.POUND_CHAR}ifndef osapi_heap_h
  ${envMap.POUND_CHAR}include "osapi/osapi_heap.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef osapi_utility_h
  ${envMap.POUND_CHAR}include "osapi/osapi_utility.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef cdr_type_h
  ${envMap.POUND_CHAR}include "cdr/cdr_type.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef cdr_type_object_h
  ${envMap.POUND_CHAR}include "cdr/cdr_typeObject.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef cdr_encapsulation_h
  ${envMap.POUND_CHAR}include "cdr/cdr_encapsulation.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef cdr_stream_h
  ${envMap.POUND_CHAR}include "cdr/cdr_stream.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}include "xcdr/xcdr_interpreter.h"
${envMap.POUND_CHAR}include "xcdr/xcdr_stream.h"

${envMap.POUND_CHAR}ifndef cdr_log_h
  ${envMap.POUND_CHAR}include "cdr/cdr_log.h"
${envMap.POUND_CHAR}endif


${envMap.POUND_CHAR}ifndef pres_typePlugin_h
  ${envMap.POUND_CHAR}include "pres/pres_typePlugin.h"
${envMap.POUND_CHAR}endif

#if(!$userVarList.noEndpointBuild)
${envMap.POUND_CHAR}include "dds_c/dds_c_typecode_impl.h"
#end

${envMap.POUND_CHAR}define RTI_CDR_CURRENT_SUBMODULE RTI_CDR_SUBMODULE_MASK_STREAM

#if($envMap.allocateWithNew)
${envMap.POUND_CHAR}include <new>
#end

#addStringIncludes()

${envMap.POUND_CHAR}include "${envMap.idlFileName}Plugin.h"


#*--*##foreach($node in $constructMapList)
##if it is a directive we print its value
#*----*##if($node.constructKind=="directive") 
##we avoid to copy the declaration directives
#*------*##if($node.directiveKind=="copy-c"||$node.directiveKind=="copy") 
$node.value
#*------*##end
#*----*##elseif($node.constructKind=="module" && ${envMap.namespace})
namespace $node.name {
#*----*##elseif($node.constructKind=="moduleClose" && ${envMap.namespace}) 
} /* namespace $node.name  */
#*----*##elseif(($node.constructKind=="alias" && !$node.languageBinding.equals("FLAT_DATA"))
           ||($node.isAggregationType))

/* ----------------------------------------------------------------------------
 *  Type ${node.nativeFQNameInModule}
 * -------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    Support functions:
 * -------------------------------------------------------------------------- */

${node.nativeFQNameInModule}*
${node.nativeFQNameInModule}PluginSupport_create_data_w_params(
    const struct DDS_TypeAllocationParams_t * alloc_params) 
{
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    RTIOsapiUtility_unusedParameter(alloc_params);
    return ${node.nativeFQNameInModule}::create_data();
#*----*##else
    ${node.nativeFQNameInModule} *sample = NULL;
    
    if (alloc_params == NULL) {
        return NULL;
    } else if(!alloc_params->allocate_memory) {
##   Using Cdr log due to internal inter-dependencies of the other logging methods
    	RTICdrLog_exception(&RTI_CDR_LOG_TYPE_OBJECT_NOT_ASSIGNABLE_ss,
        		"alloc_params->allocate_memory","false");
		return NULL;
    }

#*--*##allocPointerObjectNoCheck ("sample" "${node.nativeFQNameInModule}" $node.isAliasOfArray false)
    if (sample == NULL) {
    	return NULL;
    }
    
#*--*##if(!$envMap.generateCppConstructor)
    if (!${node.nativeFQName}_initialize_w_params(sample,alloc_params)) {
        struct DDS_TypeDeallocationParams_t deallocParams =
        DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT;
        deallocParams.delete_pointers = alloc_params->allocate_pointers;
        deallocParams.delete_optional_members = alloc_params->allocate_pointers;
        /* Coverity reports a possible uninit_use_in_call that will happen if the
        allocation fails. But if the allocation fails then sample == null and
        the method will return before reach this point.*/
        /* Coverity reports a possible overwrite_var on the members of the sample.
         It is a false positive since all the pointers are freed before assigning
         null to them. */
        /* coverity[uninit_use_in_call : FALSE] */
        /* coverity[overwrite_var : FALSE] */
        ${node.nativeFQName}_finalize_w_params(sample, &deallocParams);
        /* Coverity reports a possible leaked_storage on the sample members when 
         freeing sample. It is a false positive since all the members' memory 
         is freed in the call "${node.nativeFQName}_finalize_ex" */
        /* coverity[leaked_storage : FALSE] */
#*----*##deletePointerObject ("sample" $node.isAliasOfArray true false)
    }
#*--*##else

#*----*##if ($node.constructKind=="alias")    
    try {
        ${node.nativeFQName}_construct_w_params(sample, alloc_params);
    } catch(const std::bad_alloc&) {
#*------*##deletePointerObject ("sample" $node.isAliasOfArray true false)
        return NULL;
    }
#*----*##end

#*--*##end
    return sample;
#*----*##end ## FLAT_DATA
} 

${node.nativeFQNameInModule} *
${node.nativeFQNameInModule}PluginSupport_create_data_ex(RTIBool allocate_pointers) 
{
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    RTIOsapiUtility_unusedParameter(allocate_pointers);
    return ${node.nativeFQNameInModule}::create_data();
#*----*##else    
    ${node.nativeFQNameInModule} *sample = NULL;

#*--*##if($envMap.generateCppConstructor && $node.constructKind!="alias")
    if (allocate_pointers) {}
#*--*##end

#*--*##allocPointerObjectNoCheck ("sample" "${node.nativeFQNameInModule}" $node.isAliasOfArray false)

    if(sample == NULL) {
        return NULL;
    }

#*--*##if(!$envMap.generateCppConstructor)
    if (!${node.nativeFQName}_initialize_ex(sample,allocate_pointers, RTI_TRUE)) {
        /* Coverity reports a possible uninit_use_in_call that will happen if the
         new fails. But if new fails then sample == null and the method will
         return before reach this point. */
        /* Coverity reports a possible overwrite_var on the members of the sample.
         It is a false positive since all the pointers are freed before assigning
         null to them. */
        /* coverity[uninit_use_in_call : FALSE] */
        /* coverity[overwrite_var : FALSE] */
        ${node.nativeFQName}_finalize_ex(sample, RTI_TRUE);
        /* Coverity reports a possible leaked_storage on the sample members when 
         freeing sample. It is a false positive since all the members' memory 
         is freed in the call "${node.nativeFQName}_finalize_ex" */
        /* coverity[leaked_storage : FALSE] */
#*----*##deletePointerObject ("sample" $node.isAliasOfArray true false)
    }
#*--*##else

#*----*##if ($node.constructKind=="alias")    
    try {
	    struct DDS_TypeAllocationParams_t allocParams =
	        DDS_TYPE_ALLOCATION_PARAMS_DEFAULT;
        
        allocParams.allocate_pointers =  (DDS_Boolean)allocate_pointers;
        allocParams.allocate_memory = (DDS_Boolean)RTI_TRUE;

        ${node.nativeFQName}_construct_w_params(sample, &allocParams);
    } catch(const std::bad_alloc&) {
#*------*##deletePointerObject ("sample" $node.isAliasOfArray true false)
        return NULL;
    }
#*----*##end

#*--*##end

    return sample;
#*----*##end ## FLAT_DATA    
}

#*-****************************************************************-*#
${node.nativeFQNameInModule} *
${node.nativeFQNameInModule}PluginSupport_create_data(void)
{
#*--*##if($node.hasCycle)
    return ${node.nativeFQName}PluginSupport_create_data_ex(RTI_FALSE);
#*--*##else
    return ${node.nativeFQName}PluginSupport_create_data_ex(RTI_TRUE);
#*--*##end
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_data_w_params(
    ${node.nativeFQNameInModule} *sample,
    const struct DDS_TypeDeallocationParams_t * dealloc_params) {
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    RTIOsapiUtility_unusedParameter(dealloc_params);
    ${node.nativeFQNameInModule}::delete_data(sample);
#*----*##else
    ${node.nativeFQName}_finalize_w_params(sample,dealloc_params);

#*--*##deletePointerObject ("sample" $node.isAliasOfArray false false)
#*----*##end ## FLAT_DATA
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_data_ex(
    ${node.nativeFQNameInModule} *sample,RTIBool deallocate_pointers) {
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    RTIOsapiUtility_unusedParameter(deallocate_pointers);
    ${node.nativeFQNameInModule}::delete_data(sample);
#*----*##else
    ${node.nativeFQName}_finalize_ex(sample,deallocate_pointers);

#*--*##deletePointerObject ("sample" $node.isAliasOfArray false false)
#*----*##end ## FLAT_DATA
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_data(
    ${node.nativeFQNameInModule} *sample) {

    ${node.nativeFQName}PluginSupport_destroy_data_ex(sample,RTI_TRUE);

}


#*-****************************************************************-*#
RTIBool 
${node.nativeFQNameInModule}PluginSupport_copy_data(
    ${node.nativeFQNameInModule} *dst,
    const ${node.nativeFQNameInModule} *src)
{
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    RTIOsapiUtility_unusedParameter(dst);
    RTIOsapiUtility_unusedParameter(src);
    return RTI_FALSE; // flat-data types cannot be copied
#*----*##else    
    return ${node.nativeFQName}_copy(dst,(const ${node.nativeFQNameInModule}*) src);
#*----*##end ## FLAT_DATA    
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_print_data(
    const ${node.nativeFQNameInModule} *sample,
    const char *desc,
    unsigned int indent_level)
{
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    DDS_PrintFormatProperty property; // default property
    DDS_UnsignedLong str_size = 0;

    RTIOsapiUtility_unusedParameter(indent_level);

    if (desc != NULL) {
      RTILogParamString_printPlain("%s:\n", desc);
    } else {
      RTILogParamString_printPlain("\n");
    }
    
    if (${node.nativeFQNameInModule}Plugin_data_to_string(
            sample,
            NULL,
            &str_size,
            &property) != DDS_RETCODE_OK) {
        return;
    }

    char *str = DDS_String_alloc(str_size);
    if (str == NULL) {
        return;
    }

    if (${node.nativeFQNameInModule}Plugin_data_to_string(
            sample,
            str,
            &str_size,
            &property) != DDS_RETCODE_OK) {
        DDS_String_free(str);
        return;
    }

    printf("%s", str);
    DDS_String_free(str);
#*----*##else ## FLAT_DATA

    RTICdrType_printIndent(indent_level);

    if (desc != NULL) {
      RTILogParamString_printPlain("%s:\n", desc);
    } else {
      RTILogParamString_printPlain("\n");
    }

    if (sample == NULL) {
      RTILogParamString_printPlain("NULL\n");
      return;
    }

#*-****************************************************************-*#
#*------*##if(${node.baseTypeFQName})
${node.baseTypeFQName}PluginSupport_print_data((const ${node.baseTypeFQName}*)sample,"",indent_level);
#*------*##end

#*------*##if($node.constructKind=="union")
#*--------*##printMember($node.unionDiscriminatorMap)

#*--------*##if($node.needsSwitchCode)
switch(sample->_d) {
#*--------*##end
#*------*##end 

#*------*##print($node) ## Call to a macro toy print the members

#*------*##if($node.needsSwitchCode)
#*--------*##if($node.needsDefaultCase)
    default: 
    {
        /* 
         * Prevents compiler warnings when discriminator is an enum
         * and unionType does not specify all enumeration members.
         */  
    }

#*--------*##end    
    }
#*------*##end
#*----*##end ## FLAT_DATA         
}

##----------------------------------------------------
## This code is only generated if the struct has a key
##----------------------------------------------------
#*------*##if($node.hasKey ||  $node.hasKeyBaseType)
${node.nativeFQNameInModule} *
${node.nativeFQNameInModule}PluginSupport_create_key_ex(RTIBool allocate_pointers){
#*--*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    RTIOsapiUtility_unusedParameter(allocate_pointers);
    return ${node.nativeFQNameInModule}::create_data();
#*--*##else 
   ${node.nativeFQNameInModule} *key = NULL;

#*--*##if($envMap.generateCppConstructor)
    if (allocate_pointers) {}
#*--*##end

#*--*##allocPointerObjectNoCheck ("key" "${node.nativeFQNameInModule}KeyHolder" false false)

#*--*##if(!$envMap.generateCppConstructor)
    ${node.nativeFQName}_initialize_ex(key,allocate_pointers, RTI_TRUE);
#*--*##end

    return key;
#*--*##end
}

#*-****************************************************************-*#
${node.nativeFQNameInModule} *
${node.nativeFQNameInModule}PluginSupport_create_key(void)
{
    return  ${node.nativeFQName}PluginSupport_create_key_ex(RTI_TRUE);
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_key_ex(
   ${node.nativeFQNameInModule}KeyHolder *key,RTIBool deallocate_pointers)
{
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    RTIOsapiUtility_unusedParameter(deallocate_pointers);

    ${node.nativeFQNameInModule}::delete_data(key);
#*----*##else
    ${node.nativeFQName}_finalize_ex(key,deallocate_pointers);

#*----*##deletePointerObject ("key" $node.isAliasOfArray false false)
#*----*##end
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_key(
   ${node.nativeFQNameInModule}KeyHolder *key) {

  ${node.nativeFQName}PluginSupport_destroy_key_ex(key,RTI_TRUE);

}
#*------*##end ##if struct.hasKey

/* ----------------------------------------------------------------------------
    Callback functions:
 * ---------------------------------------------------------------------------- */

#*------*##if (($node.isAggregationType)
                  &&($node.topLevel=="true"))

#*--------*##if($node.isMetpType)
${node.nativeFQNameInModule}*
${node.nativeFQNameInModule}Plugin_create_metp_data(void)
{
    return (${node.nativeFQNameInModule}*)PRES_TYPE_PLUGIN_INVALID_SAMPLE_ADDRESS;
}

void
${node.nativeFQNameInModule}Plugin_destroy_metp_data(void* sample)
{
    RTIOsapiUtility_unusedParameter(sample);
}
#*--------*##end
#*--------*##if($node.isMetpType || $node.languageBinding.equals("FLAT_DATA"))
RTI_UINT32
${node.nativeFQNameInModule}Plugin_get_deserialized_sample_max_size(
    PRESTypePluginEndpointData epd)
{
#*------*##if(!($node.languageBinding.equals("FLAT_DATA")
        && $node.extensibility.equals("MUTABLE_EXTENSIBILITY"))) 
    RTIOsapiUtility_unusedParameter(epd);
#*------*##end
#*------*##if($node.languageBinding.equals("FLAT_DATA"))    
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    return RTIOsapiAlignment_alignUInt32Up(
            PRESTypePluginDefaultEndpointData_getMaxSizeSerializedSample(epd),
            MIG_RTPS_SUBMESSAGE_ALIGNMENT);
#*--------*##else
    return RTI_XCDR_ENCAPSULATION_HEADER_SIZE
            + RTIOsapiAlignment_alignUInt32Up(
                    ${node.nativeFQNameInModule}Offset::serialized_size(0),
                    MIG_RTPS_SUBMESSAGE_ALIGNMENT);
#*--------*##end
#*------*##else
    return (RTI_UINT32)sizeof(${node.nativeFQNameInModule});
#*------*##end
}
#*--------*##end

#*------*##if($node.languageBinding.equals("FLAT_DATA"))
#flatPluginTopLevelSupportFunctions($node)
#*------*##end

PRESTypePluginParticipantData 
${node.nativeFQNameInModule}Plugin_on_participant_attached(
    void *registration_data,
    const struct PRESTypePluginParticipantInfo *participant_info,
    RTIBool top_level_registration,
    void *container_plugin_context,
    RTICdrTypeCode *type_code)
{
#*--*##if($node.isMetpType && !$node.interpreted=="true")
    PRESTypePluginParticipantData epd;
#*--*##end
#*--*##if($node.interpreted=="true")
#*----*##if(!$userVarList.noEndpointBuild)
    struct RTIXCdrInterpreterPrograms *programs = NULL;
    struct RTIXCdrInterpreterProgramsGenProperty programProperty =
    		RTIXCdrInterpreterProgramsGenProperty_INITIALIZER;
#*----*##end
    struct PRESTypePluginDefaultParticipantData *pd = NULL;
#*--*##end
  
#*--*##if(!$node.isMetpType)
    if (registration_data) {} /* To avoid warnings */
    if (participant_info) {} /* To avoid warnings */
    if (top_level_registration) {} /* To avoid warnings */
    if (container_plugin_context) {} /* To avoid warnings */
    if (type_code) {} /* To avoid warnings */
#*--*##end
  #set($node.allowXcdr=true)

#*--*##if($node.interpreted=="true")
    pd = (struct PRESTypePluginDefaultParticipantData *)
            PRESTypePluginDefaultParticipantData_new(participant_info);

#*----*##if(!$userVarList.noEndpointBuild)
    #initializeProgramProperties($node)

    programs = DDS_TypeCodeFactory_assert_programs_in_global_list(
            DDS_TypeCodeFactory_get_instance(),
#*------*##if($node.languageBinding.equals("FLAT_DATA"))            
            ${node.nativeFQNameInModule}PlainHelper_get_typecode(),
#*------*##else
            ${node.nativeFQNameInModule}_get_typecode(),
#*------*##end
            &programProperty,
            RTI_XCDR_PROGRAM_MASK_TYPEPLUGIN);
    if (programs == NULL) {
        PRESTypePluginDefaultParticipantData_delete(
            (PRESTypePluginParticipantData) pd);
        return NULL;
    }

    pd->programs = programs;
#*----*##end
#*----*##if(!$node.isMetpType)    
    return (PRESTypePluginParticipantData)pd;
#*----*##else
    return METypePlugin_on_participant_attached(
            pd,
            registration_data,
            participant_info,
            top_level_registration,
            container_plugin_context,
            type_code);
#*----*##end
#*--*##else

#*----*##if($node.isMetpType)
    epd = PRESTypePluginDefaultParticipantData_new(participant_info);
    return METypePlugin_on_participant_attached(
        epd,
        registration_data,
        participant_info,
        top_level_registration,
        container_plugin_context,
        type_code);
#*----*##else
    return PRESTypePluginDefaultParticipantData_new(participant_info);
#*----*##end
#*--*##end
}
#*-****************************************************************-*#

void 
${node.nativeFQNameInModule}Plugin_on_participant_detached(
    PRESTypePluginParticipantData participant_data)
{  		
    if (participant_data != NULL) {
#*--*##if($node.interpreted=="true")
#*----*##if(!$userVarList.noEndpointBuild)
        struct PRESTypePluginDefaultParticipantData *pd = 
                (struct PRESTypePluginDefaultParticipantData *)participant_data;

        if (pd->programs != NULL) {
            DDS_TypeCodeFactory_remove_programs_from_global_list(
                    DDS_TypeCodeFactory_get_instance(),
                    pd->programs);
            pd->programs = NULL;
        }
#*----*##end
#*----*##if($node.isMetpType)
        METypePlugin_on_participant_detached(participant_data);
#*----*##end
  	    PRESTypePluginDefaultParticipantData_delete(participant_data);
#*----*##else
#*----*##if($node.isMetpType)
        METypePlugin_on_participant_detached(participant_data);
#*----*##end
        PRESTypePluginDefaultParticipantData_delete(participant_data);
#*--*##end
    }
}

#*-****************************************************************-*#

PRESTypePluginEndpointData
${node.nativeFQNameInModule}Plugin_on_endpoint_attached(
    PRESTypePluginParticipantData participant_data,
    const struct PRESTypePluginEndpointInfo *endpoint_info,
    RTIBool top_level_registration, 
    void *containerPluginContext)
{
    PRESTypePluginEndpointData epd = NULL;
    unsigned int serializedSampleMaxSize = 0;
#*--*##if($node.isMetpType)    
    void *plugin = NULL;
#*--*##end    


##----------------------------------------------------
## This code is only generated if the struct has a key 
##----------------------------------------------------

#*--*##if($node.hasKey || $node.hasKeyBaseType)
    unsigned int serializedKeyMaxSize = 0;
    unsigned int serializedKeyMaxSizeV2 = 0;
#*--*##end 

#*--*##if(!$node.isMetpType)
    if (top_level_registration) {} /* To avoid warnings */
    if (containerPluginContext) {} /* To avoid warnings */
#*--*##end

#*--*##if($node.interpreted=="true")
    if (participant_data == NULL) {
        return NULL;
    } 
#*--*##end


#*--*##if($node.isMetpType)     
   if (endpoint_info->endpointKind == PRES_TYPEPLUGIN_ENDPOINT_WRITER) {
        plugin = DDS_Entity_get_reserved_dataI(
                DDS_DataWriter_as_entity(endpoint_info->reserved));
    } else {
        plugin = DDS_Entity_get_reserved_dataI(
                DDS_DataReader_as_entity(endpoint_info->reserved));
    }
    if (plugin != NULL) {
        epd = PRESTypePluginDefaultEndpointData_new(
            participant_data,
            endpoint_info,
            (PRESTypePluginDefaultEndpointDataCreateSampleFunction)
            ${node.nativeFQNameInModule}Plugin_create_metp_data,
            (PRESTypePluginDefaultEndpointDataDestroySampleFunction)
            ${node.nativeFQNameInModule}Plugin_destroy_metp_data,
            NULL, NULL);
    } else {
        epd = PRESTypePluginDefaultEndpointData_new(
            participant_data,
            endpoint_info,
            (PRESTypePluginDefaultEndpointDataCreateSampleFunction)
            ${node.nativeFQName}PluginSupport_create_data,
            (PRESTypePluginDefaultEndpointDataDestroySampleFunction)
            ${node.nativeFQName}PluginSupport_destroy_data,
            #if($node.hasKey || $node.hasKeyBaseType)(PRESTypePluginDefaultEndpointDataCreateKeyFunction)
            ${node.nativeFQName}PluginSupport_create_key #else NULL #end,#*
            *##if($node.hasKey || $node.hasKeyBaseType)
            (PRESTypePluginDefaultEndpointDataDestroyKeyFunction)
            ${node.nativeFQName}PluginSupport_destroy_key#else NULL #end);
    }
#*--*##else
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
        if (endpoint_info->usesFstSampleDataPool) {
            epd = PRESTypePluginDefaultEndpointData_new(
                participant_data,
                endpoint_info,
                (PRESTypePluginDefaultEndpointDataCreateSampleFunction)
                ${node.nativeFQNameInModule}Plugin_create_flat_data_sentinel,
                (PRESTypePluginDefaultEndpointDataDestroySampleFunction)
                ${node.nativeFQNameInModule}Plugin_destroy_flat_data_sentinel,
                #if($node.hasKey || $node.hasKeyBaseType)(PRESTypePluginDefaultEndpointDataCreateKeyFunction)
                ${node.nativeFQName}PluginSupport_create_key #else NULL #end,#*
                *##if($node.hasKey || $node.hasKeyBaseType)
                (PRESTypePluginDefaultEndpointDataDestroyKeyFunction)
                ${node.nativeFQName}PluginSupport_destroy_key#else NULL #end);       
        } else {
#*----*##end
   epd = PRESTypePluginDefaultEndpointData_new(
            participant_data,
            endpoint_info,
            (PRESTypePluginDefaultEndpointDataCreateSampleFunction)
            ${node.nativeFQName}PluginSupport_create_data,
            (PRESTypePluginDefaultEndpointDataDestroySampleFunction)
            ${node.nativeFQName}PluginSupport_destroy_data,
            #if($node.hasKey || $node.hasKeyBaseType)(PRESTypePluginDefaultEndpointDataCreateKeyFunction)
            ${node.nativeFQName}PluginSupport_create_key #else NULL #end,#*
            *##if($node.hasKey || $node.hasKeyBaseType)
            (PRESTypePluginDefaultEndpointDataDestroyKeyFunction)
            ${node.nativeFQName}PluginSupport_destroy_key#else NULL #end);
#*----*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
        }
#*----*##end            
#*--*##end

    if (epd == NULL) {
        return NULL;
    } 
    
##----------------------------------------------------
## This code is only generated if the struct has a key
##----------------------------------------------------    
#*--*##if($node.hasKey || $node.hasKeyBaseType)
#*----*##if ($node.allowXcdr)
    serializedKeyMaxSize =  ${node.nativeFQName}Plugin_get_serialized_key_max_size(
        epd,RTI_FALSE,RTI_CDR_ENCAPSULATION_ID_CDR_BE,0);
#*----*##end
#*----*##if($node.interpreted=="true")
#*------*##if ($node.allowXcdr2)
    serializedKeyMaxSizeV2 =  ${node.nativeFQNameInModule}Plugin_get_serialized_key_max_size_for_keyhash(
            epd,
            RTI_CDR_ENCAPSULATION_ID_CDR2_BE,
            0);
#*------*##end
#*----*##end

    if(!PRESTypePluginDefaultEndpointData_createMD5StreamWithInfo(
            epd,
            endpoint_info,
            serializedKeyMaxSize,
            serializedKeyMaxSizeV2))  
    {
        PRESTypePluginDefaultEndpointData_delete(epd);
        return NULL;
    }
    
#*----*##if($node.languageBinding.equals("FLAT_DATA"))
#flatPluginCreatePlainHelperSample($node)  
#*----*##end    

#*--*##end ##if struct.hasKey

#*--*##if(($node.isAggregationType))
#*----*##if($node.languageBinding.equals("FLAT_DATA"))
    serializedSampleMaxSize = ${node.nativeFQName}Plugin_get_serialized_sample_max_size(
            epd,RTI_TRUE,RTI_XCDR_ENCAPSULATION_ID_PL_CDR2_BE,0);
    PRESTypePluginDefaultEndpointData_setMaxSizeSerializedSample(
            epd,serializedSampleMaxSize);
#*----*##end
#*--*##end 
    if (endpoint_info->endpointKind == PRES_TYPEPLUGIN_ENDPOINT_WRITER) {
#*--*##if(($node.isAggregationType))
#*----*##if(!($node.languageBinding.equals("FLAT_DATA")))
#*------*##if($node.allowXcdr)
        serializedSampleMaxSize = ${node.nativeFQName}Plugin_get_serialized_sample_max_size(
            epd,RTI_FALSE,RTI_CDR_ENCAPSULATION_ID_CDR_BE,0);
#*------*##end
        PRESTypePluginDefaultEndpointData_setMaxSizeSerializedSample(epd, serializedSampleMaxSize);
#*----*##end
#*--*##end    

        if (PRESTypePluginDefaultEndpointData_createWriterPool(
                epd,
                endpoint_info,
            (PRESTypePluginGetSerializedSampleMaxSizeFunction)
                ${node.nativeFQName}Plugin_get_serialized_sample_max_size, epd,
            (PRESTypePluginGetSerializedSampleSizeFunction)
            #getSerializedSampleSizeFncName($node),
            epd) == RTI_FALSE) {
            PRESTypePluginDefaultEndpointData_delete(epd);
            return NULL;
        }
    }
#*--*##if($node.isMetpType)
    if (!METypePlugin_on_endpoint_attached(
    	participant_data,
    	epd,
    	endpoint_info,
    	top_level_registration,
    	containerPluginContext,
        ${node.nativeFQNameInModule}Plugin_get_deserialized_sample_max_size(epd),
        (RTIBool(*)(void *))${node.nativeFQNameInModule}_initialize)) {
        PRESTypePluginDefaultEndpointData_delete(epd);
        return NULL;
    }
#*--*##end 

    return epd;    
}

#*-****************************************************************-*#

void 
${node.nativeFQNameInModule}Plugin_on_endpoint_detached(
    PRESTypePluginEndpointData endpoint_data)
{
#*--*##if($node.isMetpType)  
    METypePlugin_on_endpoint_detached(endpoint_data);
#*--*##end
#*--*##if($node.languageBinding.equals("FLAT_DATA"))
#flatPluginDeletePlainHelperSample($node)
#*--*##end
    PRESTypePluginDefaultEndpointData_delete(endpoint_data);
}

#*-****************************************************************-*#
void    
${node.nativeFQNameInModule}Plugin_return_sample(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *sample,
    void *handle)
{
    ${node.nativeFQNameInModule}_finalize_optional_members(sample, RTI_TRUE);
           
    PRESTypePluginDefaultEndpointData_returnSample(
        endpoint_data, sample, handle);
}
 
void ${node.nativeFQNameInModule}Plugin_finalize_optional_members(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule}* sample,
    RTIBool deletePointers)
{
    RTIOsapiUtility_unusedParameter(endpoint_data);
    ${node.nativeFQNameInModule}_finalize_optional_members(
        sample, deletePointers);
}

#*-****************************************************************-*#
#*------*##end



RTIBool 
${node.nativeFQNameInModule}Plugin_copy_sample(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *dst,
    const ${node.nativeFQNameInModule} *src)
{
    if (endpoint_data) {} /* To avoid warnings */
    return ${node.nativeFQName}PluginSupport_copy_data(dst,src);
}
#*----*##end
#*----*##if(($node.constructKind=="alias")
            || ($node.constructKind=="enum") 
            ||($node.isAggregationType))
           

/* ----------------------------------------------------------------------------
    (De)Serialize functions:
 * ------------------------------------------------------------------------- */
#*------*##if (($node.isAggregationType)
                ||($node.constructKind=="alias" && !$node.languageBinding.equals("FLAT_DATA"))) 
unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment);
#*------*##end

#*--*##if (!$node.skipTypePluginCodeGen)
RTIBool 
${node.nativeFQNameInModule}Plugin_serialize(
    PRESTypePluginEndpointData endpoint_data,
    const ${node.nativeFQNameInModule} *sample, 
    struct RTICdrStream *stream,    
    RTIBool serialize_encapsulation,
    RTIEncapsulationId encapsulation_id,
    RTIBool serialize_sample, 
    void *endpoint_plugin_qos)
{
#*--*##if ($node.languageBinding.equals("FLAT_DATA") && !$node.isMetpType)
#flatPluginSerializeBody($node true)
#*--*##elseif ($node.interpreted=="true")
    RTIBool retval = RTI_TRUE;
#*----*##if($node.isMetpType)
    RTIBool metp = RTI_FALSE;
    char * rti_position = NULL;
    RTIBool serialize_encapsulation_requested = serialize_encapsulation;
#*----*##serializeEncapsulation($node)
    if(metp && serialize_sample) {
        if (!METypePlugin_serialize(
                endpoint_data,
                sample,
                stream,
                serialize_encapsulation,
                encapsulation_id,
                serialize_sample,
                endpoint_plugin_qos)) {
            return RTI_FALSE;
        }
        return RTI_TRUE; 
    } else if (!metp && METypePlugin_cdrEnabled(endpoint_data) && serialize_sample) {
        serialize_encapsulation = RTI_FALSE;
#*------*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
#*--------*##flatPluginSerializeBody($node false)
#*------*##end 
#*----*##end ## isMetpType
#*------*##if (!($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp")))  
    retval = PRESTypePlugin_interpretedSerialize(
    	endpoint_data,
    	sample, 
    	stream,    
    	serialize_encapsulation,
    	encapsulation_id,
    	serialize_sample, 
    	endpoint_plugin_qos);
#*------*##end
#*----*##if($node.isMetpType)
    } else if (serialize_sample) {
        return RTI_FALSE;
    }
    if (serialize_encapsulation_requested) {
        RTICdrStream_restoreAlignment(stream,rti_position);
    }
#*----*##end
    return retval;
#*--*##else ## not interpreted
   char * rti_position = NULL;
#*------*##if($node.isMetpType)   
   RTIBool metp = RTI_FALSE;
#*------*##end
#*------*##if(($node.isMetpType) || ($node.constructKind!="enum"))
   RTIBool retval = RTI_TRUE;
#*------*##end   
#*------*##if($node.constructKind!="enum")
    
#*--------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
|| ($node.hasOptionalMember))
#*----------*##if ($node.memberCount > 0)
    DDS_UnsignedLong memberId = 0;
    char *memberLengthPosition = NULL;
    RTIBool extended;
    struct RTICdrStreamState state;
#*----------*##end
#*--------*##end
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    RTIBool ignoreListEndId = RTI_FALSE;
#*--------*##end
#*------*##end

#*------*##if(!$node.baseTypeFQName) 
#*--------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY") 
                 || $node.hasOptionalMember)
                 && $node.constructKind!="enum")
    if (endpoint_data == NULL) {
        return RTI_FALSE;
    }
#*------*##else
    if (endpoint_data) {}
#*------*##end
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*------*##end  
 
#*------*##serializeEncapsulation($node)

  
#*------*##if($node.isMetpType)
  if(metp && serialize_sample) {
#*------*##else
  if(serialize_sample) {
#*------*##end
#if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY") || $node.hasOptionalMember)
     &&$node.constructKind!="enum")
      if (RTICdrStream_isDirty(stream)) {
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
            ignoreListEndId = stream->_xTypesState.skipListEndId;
#*--------*##end
      } else {
            /* Top level */
            RTICdrStream_setDirtyBit(stream,RTI_TRUE);


#*------------*##if ($envMap.mutExtCode)
                stream->_xTypesState.useExtendedId = RTI_TRUE;
#*------------*##else
                if (PRESTypePluginDefaultEndpointData_getMaxSizeSerializedSample(endpoint_data) > 65535) {
                    stream->_xTypesState.useExtendedId = RTI_TRUE;
                } else {
                    stream->_xTypesState.useExtendedId = RTI_FALSE;
                }
#*------------*##end
       }
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
        stream->_xTypesState.skipListEndId = RTI_FALSE;
#*--------*##end


#*------*##end
#*------*##if($node.isMetpType)
        if (!METypePlugin_serialize(
        	endpoint_data,
        	sample,
        	stream,
        	serialize_encapsulation,
        	encapsulation_id,
        	serialize_sample,
                endpoint_plugin_qos)) {
            return RTI_FALSE;
        }
    } else if(!metp && METypePlugin_cdrEnabled(endpoint_data) && serialize_sample) {
        if (serialize_encapsulation) {
            METypePlugin_set_sample_serialized((const void*)sample);
        }
#*------*##end
  
#*------*##if ($node.constructKind=="enum")
if (#*
--------*##foreach($element in $node.memberFieldMapList)
*sample != $element.nativeFQNameInModule#*
----------*##if($foreach.count <$node.memberFieldMapList.size()) && #end   
#*--------*##end
){
    RTICdrLog_exception(
               &RTI_CDR_LOG_SERIALIZE_INVALID_ENUMERATOR_ds, 
               *sample, 
               "${node.nativeFQNameInModule}");
        return RTI_FALSE;       
    }

    if (!RTICdrStream_serializeEnum(stream, sample))
    {
       return RTI_FALSE;
    }
  
#*------*##else  
#*--------*##if($node.baseTypeFQName)  
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    stream->_xTypesState.skipListEndId = RTI_TRUE;
#*----------*##end
    if (!${node.baseTypeFQName}Plugin_serialize(endpoint_data,
             (const ${node.baseTypeFQName}*)sample,stream,RTI_FALSE,encapsulation_id,
             RTI_TRUE,endpoint_plugin_qos)) {
        return RTI_FALSE;
    }
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    stream->_xTypesState.skipListEndId = RTI_FALSE;
#*----------*##end    
#*--------*##end  
#*------*##if($node.constructKind=="union")
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
        memberId = $node.unionDiscriminatorMap.id;
#*----------*##if($node.unionDiscriminatorMap.needExtendedId=="yes" )       
        extended = RTI_TRUE;
#*----------*##elseif($node.unionDiscriminatorMap.needExtendedId=="no")
        extended = RTI_FALSE;
#*----------*##else
        extended = stream->_xTypesState.useExtendedId;
#*----------*##end                                   
        memberLengthPosition = RTICdrStream_serializeParameterHeader(
                                   stream, &state, extended, memberId, RTI_FALSE);
        if (memberLengthPosition == NULL) {
            return RTI_FALSE;
        }
#*------*##end                                   
#*--------*##serializeMember($node.unionDiscriminatorMap "")
#if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    if (!RTICdrStream_serializeParameterLength(
             stream, &state, extended, memberLengthPosition)) {
        return RTI_FALSE;
    } 
#end    
    switch(sample->_d) {
#*--------*##end 

#*--------*##serialize( $node.memberFieldMapList "serialize")
#*------*##end

#*------*##if($node.needsDefaultCase.equals("true"))
    default: 
    {
        /* 
         * Prevents compiler warnings when discriminator is an enum
         * and unionType does not specify all enumeration members.
         */ 
    }
#*------*##end

#*------*##if($node.constructKind=="union")
    }
#*------*##end  

#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&$node.constructKind!="enum") 
#*------*##serializeEndMutable()
#*------*##end        
}
#*------*##if($node.isMetpType)
else if (serialize_sample) {
    retval = RTI_FALSE;
}
#*------*##end
 
  if(serialize_encapsulation) {
    RTICdrStream_restoreAlignment(stream,rti_position);
  }

#*------*##if((!$node.isMetpType) && ($node.constructKind=="enum"))
  return RTI_TRUE;
#*------*##else
  return retval;
#*------*##end
#*--*##end
}

#*----*##if ($userVarList.testSupport && $node.isAggregationType)
RTIBool
${node.nativeFQNameInModule}Plugin_serialize_test_only(
        const ${node.nativeFQNameInModule} *sample,
        struct RTICdrStream *stream,
        RTIBool serialize_encapsulation,
        RTIEncapsulationId encapsulation_id,
        RTIBool serialize_sample,
        void *endpoint_plugin_qos)
{
#*------*##createEndpointData($node)

    return ${node.nativeFQNameInModule}Plugin_serialize(
            (PRESTypePluginEndpointData) &epd,
            sample,
            stream,
            serialize_encapsulation,
            encapsulation_id,
            serialize_sample,
            endpoint_plugin_qos);
}
#*----*##end #* $userVarList.testSupport && $node.isAggregationType *#
#*--*##end #* $node.skipTypePluginCodeGen *#

#*-****************************************************************-*#

#*--*##if (!$node.skipTypePluginCodeGen)
RTIBool 
${node.nativeFQNameInModule}Plugin_deserialize_sample(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *sample,
    struct RTICdrStream *stream,   
    RTIBool deserialize_encapsulation,
    RTIBool deserialize_sample, 
    void *endpoint_plugin_qos)
{
#*--*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    RTIOsapiUtility_unusedParameter(endpoint_data);
    RTIOsapiUtility_unusedParameter(sample);
    RTIOsapiUtility_unusedParameter(stream);
    RTIOsapiUtility_unusedParameter(deserialize_encapsulation);
    RTIOsapiUtility_unusedParameter(deserialize_sample);
    RTIOsapiUtility_unusedParameter(endpoint_plugin_qos);
    
    return RTI_FALSE;
#*--*##elseif ($node.interpreted=="true")
	return PRESTypePlugin_interpretedDeserialize(
    	endpoint_data,
    	sample,
    	stream,   
    	deserialize_encapsulation,
    	deserialize_sample, 
    	endpoint_plugin_qos);

#*--*##else
    char * rti_position = NULL;
#*-—————*##if($node.isMetpType)
    RTIBool metp = RTI_FALSE;
#*------*##end     
#*------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType" ) 
                 && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
                                                                   
    RTIBool done = RTI_FALSE;
#*------*##elseif(($node.constructKind=="enum") 
                    && (!$node.extensibility.equals("FINAL_EXTENSIBILITY")))
    DDS_Enum enum_tmp;
#*------*##end

#*------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&$node.constructKind!="enum")
|| $node.hasOptionalMember)
    DDS_UnsignedLong memberId = 0;
    DDS_UnsignedLong length = 0;
    RTIBool mustUnderstand = RTI_FALSE;
    struct RTICdrStreamState state;
    RTIBool extended;
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
 RTIBool end = RTI_FALSE;
#*--------*##end
#*------*##end

#*--*##if($envMap.allocateWithNew)
    try {
#*--*##end

#*--*##if(!$node.baseTypeFQName) 
#*------*##if (($node.constructKind=="enum") 
                 && (!$node.extensibility.equals("FINAL_EXTENSIBILITY")))
    if (endpoint_data == NULL) {
        return RTI_FALSE;
    }
#*------*##else
    if (endpoint_data) {} /* To avoid warnings */
#*------*##end
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*--*##end    
#*--*##deserializeEncapsulation ($node)
    if(deserialize_sample) {
    
#*------*##if (($node.constructKind=="enum") 
                 && (!$node.extensibility.equals("FINAL_EXTENSIBILITY")))
    if (!RTICdrStream_deserializeLong(stream, &enum_tmp))
    {
     return RTI_FALSE;
    }
    switch (enum_tmp) {
#*--------*##foreach($element in $node.memberFieldMapList)
#*----------*##if(!$element.duplicated)
        case $element.nativeFQNameInModule:
            *sample=$element.nativeFQNameInModule;
             break;
#*----------*##end   
#*--------*##end             
        default:
            {
                struct PRESTypePluginDefaultEndpointData * epd =
                        (struct PRESTypePluginDefaultEndpointData *)
                                endpoint_data;
                const PRESTypePluginSampleAssignabilityProperty * ap =
                        PRESTypePluginDefaultEndpointData_getAssignabilityProperty(epd);

                                
                if (ap->acceptUnknownEnumValue) {
                    ${node.nativeFQNameInModule}_initialize(sample);
                } else {
                    stream->_xTypesState.unassignable = RTI_TRUE;
                    RTICdrLog_exception(
                       &RTI_CDR_LOG_DESERIALIZE_INVALID_ENUMERATOR_ds, 
                       enum_tmp, 
                       "${node.nativeFQNameInModule}");
                    return RTI_FALSE;
                }
            }
    }
      
#*------*##elseif ($node.constructKind=="enum")
if (!RTICdrStream_deserializeLong(stream, sample))
    {
     return RTI_FALSE;
    }
#*------*##else
#*--------*##if(($node.constructKind!="union")&&(!$node.extensibility.equals("FINAL_EXTENSIBILITY")))
    ${node.nativeFQName}_initialize_ex(sample, RTI_FALSE, RTI_FALSE);
#*--------*##end    
#*--------*##if($node.baseTypeFQName) 
#*----------*##if (($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) )
    {
        char *begin = RTICdrStream_getCurrentPosition(stream);
        RTICdrStream_pushState(stream, &state, -1);
#*----------*##end        
        if (!${node.baseTypeFQName}Plugin_deserialize_sample(endpoint_data,
                  (${node.baseTypeFQName} *)sample,stream,RTI_FALSE,RTI_TRUE,
                  endpoint_plugin_qos)) {
              return RTI_FALSE;
        }
#*----------*##if (($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) )        
        RTICdrStream_popState(
                stream, &state);
            RTICdrStream_setCurrentPosition(stream, begin);
        }     
#*----------*##end
#*--------*##end

#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))   
        while (end != RTI_TRUE && RTICdrStream_getRemainder(stream) > 0) {
#*--------*##mutableDeserializeHeader()
#*--------*##deserializeMutableType($node "deserialize_sample")
        }
#*------*##else
#*----------*##if($node.constructKind=="union")
#*------------*##deserializeMember( $node.unionDiscriminatorMap "deserialize_sample")
    switch(sample->_d) {
#*----------*##end 
#*------------*##deserialize( $node.memberFieldMapList "deserialize_sample")
#*----------*##if($node.constructKind=="union")
#*------*##if($node.needsDefaultCase.equals("true"))
    default: 
    {
        /* 
         * Prevents compiler warnings when discriminator is an enum
         * and unionType does not specify all enumeration members.
         */ 
    }
#*------*##end
    }
#*----------*##end
#*--------*##end
#*------*##end  
     }


#*------*##if(($node.constructKind=="struct" || $node.constructKind=="valueType")
                && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY"))) 
done = RTI_TRUE;
#*------*##if($envMap.ignoreAlignment || $node.memberCount == 0)
    goto fin;  /* To avoid unused label warning */
#*------*##end
fin:
    if (done != RTI_TRUE && 
        RTICdrStream_getRemainder(stream) >=
           RTI_CDR_PARAMETER_HEADER_ALIGNMENT) {
        return RTI_FALSE;   
    }
#*------*##end
    if(deserialize_encapsulation) {
        RTICdrStream_restoreAlignment(stream,rti_position);
    }

    return RTI_TRUE;
    
#*--*##if($envMap.allocateWithNew)
    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
#*--*##end 
#*--*##end
}
#*--*##end #* $node.skipTypePluginCodeGen *#

 #*-****************************************************************-*#
#if($node.isAggregationType)
#*--*##if(!$userVarList.noEndpointBuild)
RTIBool
${node.nativeFQNameInModule}Plugin_serialize_to_cdr_buffer_ex(
    char *buffer,
    unsigned int *length,
    const ${node.nativeFQNameInModule} *sample,
    DDS_DataRepresentationId_t representation)
{
#*----*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    if (representation == DDS_XCDR_DATA_REPRESENTATION) {
        // Flat Data only supports XCDR2
        RTICdrLog_logWithFunctionName(
               RTI_LOG_BIT_EXCEPTION,
               "${node.nativeFQNameInModule}Plugin_serialize_to_cdr_buffer", 
               &RTI_CDR_LOG_SERIALIZE_FAILURE_s, 
               "representation id parameter must be XCDR2");            
        return RTI_FALSE;
    }
#flatPluginSerializeToCdrBufferBody($node)
#*----*##else
    RTIEncapsulationId encapsulationId = RTI_CDR_ENCAPSULATION_ID_INVALID;
    struct RTICdrStream stream;
    struct PRESTypePluginDefaultEndpointData epd;
    RTIBool result;
#*------*##if($node.interpreted=="true")
    struct PRESTypePluginDefaultParticipantData pd;
    struct RTIXCdrTypePluginProgramContext defaultProgramContext =
	    RTIXCdrTypePluginProgramContext_INTIALIZER;
    struct PRESTypePlugin plugin;
#*------*##end
    
    if (length == NULL) {
        return RTI_FALSE;
    }

    RTIOsapiMemory_zero(&epd, sizeof(struct PRESTypePluginDefaultEndpointData));
#*------*##if($node.interpreted=="true")
	epd.programContext = defaultProgramContext;
	epd._participantData = &pd;
	epd.typePlugin = &plugin;
	epd.programContext.endpointPluginData = &epd;
    plugin.typeCode = (struct RTICdrTypeCode *)
        ${node.nativeFQNameInModule}_get_typecode();
    pd.programs = ${node.nativeFQNameInModule}Plugin_get_programs();
    if (pd.programs == NULL) {
        return RTI_FALSE;
    }
    
    encapsulationId = DDS_TypeCode_get_native_encapsulation(
            (DDS_TypeCode *) plugin.typeCode,
            representation);    
#*------*##else 
    encapsulationId = DDS_DataRepresentationQosPolicy_getNativeEncapsulationWithRepresentationMask(
            representation,
            DDS_XCDR_DATA_REPRESENTATION_BIT);
#*------*##end
    if (encapsulationId == RTI_CDR_ENCAPSULATION_ID_INVALID) {
        return RTI_FALSE;
    }

    epd._maxSizeSerializedSample =
        ${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
            (PRESTypePluginEndpointData)&epd, 
            RTI_TRUE, 
            encapsulationId,
            0);
    
    if (buffer == NULL) {
        *length = 
            #getSerializedSampleSizeFncName($node)(
                (PRESTypePluginEndpointData)&epd,
                RTI_TRUE,
                encapsulationId,
                0,
                sample);
        
        if (*length == 0) {
            return RTI_FALSE;
        }
        
        return RTI_TRUE;
    }    
    
    RTICdrStream_init(&stream);
    RTICdrStream_set(&stream, (char *)buffer, *length);
    
    result = #serializeFncName($node)(
            (PRESTypePluginEndpointData)&epd,
            sample,
            &stream,
            RTI_TRUE,
            encapsulationId,
            RTI_TRUE,
            NULL);

    *length = (unsigned int) RTICdrStream_getCurrentPositionOffset(&stream);
    return result;
#*----*##end ## FLAT_DATA  
}
#*--*##end

#*--*##if(!$userVarList.noEndpointBuild)
RTIBool
${node.nativeFQNameInModule}Plugin_serialize_to_cdr_buffer(
    char *buffer,
    unsigned int *length,
    const ${node.nativeFQNameInModule} *sample)
{
    return ${node.nativeFQNameInModule}Plugin_serialize_to_cdr_buffer_ex(
        buffer,
        length,
        sample,
        DDS_AUTO_DATA_REPRESENTATION);
}
#*--*##end

#*--*##if(!$userVarList.noEndpointBuild)
RTIBool
${node.nativeFQNameInModule}Plugin_deserialize_from_cdr_buffer(
    ${node.nativeFQNameInModule} *sample,
    const char * buffer,
    unsigned int length)
{
    struct RTICdrStream stream;
    struct PRESTypePluginDefaultEndpointData epd;
#*----*##if($node.interpreted=="true")
    struct RTIXCdrTypePluginProgramContext defaultProgramContext =
        RTIXCdrTypePluginProgramContext_INTIALIZER;
	    struct PRESTypePluginDefaultParticipantData pd;
	    struct PRESTypePlugin plugin;
  
    epd.programContext = defaultProgramContext;
	epd._participantData = &pd;
	epd.typePlugin = &plugin;
	epd.programContext.endpointPluginData = &epd;
	plugin.typeCode = (struct RTICdrTypeCode *)
        ${node.nativeFQNameInModule}_get_typecode();
	pd.programs = ${node.nativeFQNameInModule}Plugin_get_programs();
    if (pd.programs == NULL) {
        return RTI_FALSE;
    }
#*----*##end
  
    epd._assignabilityProperty.acceptUnknownEnumValue = RTI_XCDR_TRUE;
    epd._assignabilityProperty.acceptUnknownUnionDiscriminator = 
            RTI_XCDR_ACCEPT_UNKNOWN_DISCRIMINATOR_AND_SELECT_DEFAULT;

    RTICdrStream_init(&stream);
    RTICdrStream_set(&stream, (char *)buffer, length);
    
    ${node.nativeFQNameInModule}_finalize_optional_members(sample, RTI_TRUE);
    return #deserializeSampleFncName($node)( 
        (PRESTypePluginEndpointData)&epd, sample,
        &stream, RTI_TRUE, RTI_TRUE, 
        NULL);
}
#*--*##end

#*--*##if(!$userVarList.noEndpointBuild)
${envMap.POUND_CHAR}if !defined(NDDS_STANDALONE_TYPE)
DDS_ReturnCode_t
${node.nativeFQNameInModule}Plugin_data_to_string(
    const ${node.nativeFQNameInModule} *sample,
    char *_str,
    DDS_UnsignedLong *str_size, 
    const struct DDS_PrintFormatProperty *property)
{
    DDS_DynamicData *data = NULL;
    char *buffer = NULL;
    unsigned int length = 0;
    struct DDS_PrintFormat printFormat;
    DDS_ReturnCode_t retCode = DDS_RETCODE_ERROR;

    if (sample == NULL) {
        return DDS_RETCODE_BAD_PARAMETER;
    }

    if (str_size == NULL) {
        return DDS_RETCODE_BAD_PARAMETER;
    }

    if (property == NULL) {
        return DDS_RETCODE_BAD_PARAMETER;
    }
#*----*##if ($node.languageBinding.equals("FLAT_DATA"))
#*------*##if (!$node.extensibility.equals("MUTABLE_EXTENSIBILITY"))    
    length = ${node.nativeFQNameInModule}Offset::serialized_size(0)
            + RTI_XCDR_ENCAPSULATION_HEADER_SIZE;
#*------*##else
    length = RTIXCdrFlatSample_getMutableSampleSize(
            reinterpret_cast<const unsigned char *>(sample),
            RTI_XCDR_ENCAPSULATION_HEADER_SIZE) 
                + RTI_XCDR_ENCAPSULATION_HEADER_SIZE; 
#*------*##end
    RTIOsapiHeap_allocateBuffer(&buffer, length, RTI_OSAPI_ALIGNMENT_DEFAULT);
    if (buffer == NULL) {
        return DDS_RETCODE_ERROR;
    }
    RTIOsapiMemory_copy(
        buffer,
        sample,
        length);
#*----*##else
    if (!${node.nativeFQNameInModule}Plugin_serialize_to_cdr_buffer(
		NULL, 
		&length, 
		sample)) {
        return DDS_RETCODE_ERROR;
    }
 
    RTIOsapiHeap_allocateBuffer(&buffer, length, RTI_OSAPI_ALIGNMENT_DEFAULT);
    if (buffer == NULL) {
        return DDS_RETCODE_ERROR;
    }
        
    if (!${node.nativeFQNameInModule}Plugin_serialize_to_cdr_buffer(
		buffer, 
		&length, 
		sample)) {
        RTIOsapiHeap_freeBuffer(buffer);
        return DDS_RETCODE_ERROR;
    }
#*----*##end
    data = DDS_DynamicData_new(
            ${node.nativeFQNameInModule}_get_typecode(), 
            &DDS_DYNAMIC_DATA_PROPERTY_DEFAULT);
    if (data == NULL) {
        RTIOsapiHeap_freeBuffer(buffer);
        return DDS_RETCODE_ERROR;
    }
    
    retCode = DDS_DynamicData_from_cdr_buffer(data, buffer, length);
    if (retCode != DDS_RETCODE_OK) {
        RTIOsapiHeap_freeBuffer(buffer);
        DDS_DynamicData_delete(data);
        return retCode;
    }
    
    retCode = DDS_PrintFormatProperty_to_print_format(
            property, 
            &printFormat);
    if (retCode != DDS_RETCODE_OK) {
        RTIOsapiHeap_freeBuffer(buffer);
        DDS_DynamicData_delete(data);
        return retCode;
    }
    
    retCode = DDS_DynamicDataFormatter_to_string_w_format(
            data, 
            _str,
            str_size, 
            &printFormat);
    if (retCode != DDS_RETCODE_OK) {
        RTIOsapiHeap_freeBuffer(buffer);
        DDS_DynamicData_delete(data);
        return retCode;
    }

    RTIOsapiHeap_freeBuffer(buffer);
    DDS_DynamicData_delete(data);
    return DDS_RETCODE_OK;
}
${envMap.POUND_CHAR}endif
#*--*##end

#*--*##if(!$userVarList.noEndpointBuild)
#*----*##if (!$node.skipTypePluginCodeGen)
RTIBool 
${node.nativeFQNameInModule}Plugin_deserialize(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} **sample,
    RTIBool * drop_sample,
    struct RTICdrStream *stream,   
    RTIBool deserialize_encapsulation,
    RTIBool deserialize_sample, 
    void *endpoint_plugin_qos)
{
    RTIBool result = RTI_FALSE;
#*------*##if($node.isMetpType)
    RTIBool metp = RTI_FALSE;
    char * rti_position = NULL;
    RTIBool deserialize_encapsulation_requested = deserialize_encapsulation;
#*------*##end       
    if (drop_sample) {} /* To avoid warnings */
#*------*##if($node.interpreted!="true")
    stream->_xTypesState.unassignable = RTI_FALSE;
#*------*##end
#*------*##if($node.isMetpType)
#*------*##deserializeEncapsulation ($node)
    deserialize_encapsulation = RTI_FALSE;
    if (metp && deserialize_sample) {
        result = METypePlugin_deserialize(
		endpoint_data,
		(void**)sample,
        	drop_sample,
        	stream,
        	deserialize_encapsulation,
        	deserialize_sample,
        	endpoint_plugin_qos);
    } else if (!metp 
            && METypePlugin_cdrEnabled(endpoint_data) 
            && deserialize_sample) {
        if (*sample == (void*)PRES_TYPE_PLUGIN_INVALID_SAMPLE_ADDRESS) {
             *sample = (${node.nativeFQNameInModule} *)
                                    METypePlugin_get_sample(endpoint_data);
#*--------*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
            RTIXCdrFlatSample_initializeEncapsulation(
                    *(char **)sample,
                    RTICdrStream_getEncapsulationKind(stream));
        }
#*----------*##flatPluginDeserializeBody($node)
#*--------*##else                                    
        }
#*--------*##end 	
#*------*##end ## isMetpType
#*------*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp") && !$node.isMetpType)    
#*--------*##flatPluginDeserializeBody($node)
#*------*##elseif (!($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp")))  
	result = #deserializeSampleFncName($node)( 
        	endpoint_data, (sample != NULL)?*sample:NULL,
        	stream, deserialize_encapsulation, deserialize_sample, 
        	endpoint_plugin_qos);
#*------*##end
#*------*##if($node.interpreted!="true")
        if (result) {
             if (stream->_xTypesState.unassignable) {
                 result = RTI_FALSE;
             }
        }
        if (!result && stream->_xTypesState.unassignable ) {
        
            RTICdrLog_exception(
               &RTI_CDR_LOG_UNASSIGNABLE_SAMPLE_OF_TYPE_s, 
               "${node.nativeFQNameInModule}");
            
        }
#*------*##end
#*------*##if($node.isMetpType)
    } else if (deserialize_sample) {
        *drop_sample = RTI_TRUE;
        result = RTI_TRUE;    	
    } else {
        result = RTI_TRUE;
    }
    if (deserialize_encapsulation_requested) {
        RTICdrStream_restoreAlignment(stream,rti_position);
    }
#*-------*##end

    return result;
 
}
#*----*##end
#*--*##end
#end
#*-****************************************************************-*#

#*--*##if (!$node.skipTypePluginCodeGen)
RTIBool ${node.nativeFQNameInModule}Plugin_skip(
    PRESTypePluginEndpointData endpoint_data,
    struct RTICdrStream *stream,   
    RTIBool skip_encapsulation,
    RTIBool skip_sample, 
    void *endpoint_plugin_qos)
{
#*--*##if ($node.interpreted=="true")
	return PRESTypePlugin_interpretedSkip(
    		endpoint_data,
    		stream,   
    		skip_encapsulation,
    		skip_sample, 
    		endpoint_plugin_qos);

#*--*##else
    char * rti_position = NULL;
    
#*------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType" )
                   && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
    RTIBool done = RTI_FALSE;
#*------*##end
#*------*##if((($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) && ($node.constructKind!="enum"))
               || ($node.hasOptionalMember))
    DDS_UnsignedLong memberId = 0;
    DDS_UnsignedLong length = 0;
    RTIBool mustUnderstand = RTI_FALSE;
    struct RTICdrStreamState state;
    RTIBool extended;
#*------*##end 

#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") && (!$node.constructKind.equals("enum")))
 RTIBool end = RTI_FALSE;
#*------*##end

#*------*##if(!$node.baseTypeFQName) 
    if (endpoint_data) {} /* To avoid warnings */
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*------*##end

    if(skip_encapsulation) {
        if (!RTICdrStream_skipEncapsulation(stream)) {
            return RTI_FALSE;
        }

        rti_position = RTICdrStream_resetAlignment(stream);
    }

    if (skip_sample) {
    
#*-------*##if($node.constructKind=="union" && $node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
     $node.unionDiscriminatorMap.nativeTypeFQName    disc;
#*----------*##elseif($node.baseTypeFQName) 
#*------------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))       
    {
        char *begin = RTICdrStream_getCurrentPosition(stream);
        RTICdrStream_pushState(stream, &state, -1);
#*------------*##end
        if (!${node.baseTypeFQName}Plugin_skip(endpoint_data,
                  stream,RTI_FALSE,RTI_TRUE,
                  endpoint_plugin_qos)) {
              return RTI_FALSE;
        }
#*------------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))      
        
        RTICdrStream_popState(
                stream, &state);
            RTICdrStream_setCurrentPosition(stream, begin);
        }     
#*------------*##end
#*------*##end   
#if($node.extensibility.equals("MUTABLE_EXTENSIBILITY")  && (!$node.constructKind.equals("enum")))       
        while (end != RTI_TRUE && RTICdrStream_getRemainder(stream) > 0) {
#*--------*##mutableDeserializeHeader()
#*------*##end   


#*------*##if($node.constructKind=="enum")   
        if (!RTICdrStream_skipEnum(stream)) {
            return RTI_FALSE;
        }
#*------*##else   
    
#*--------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))  
                && ($node.constructKind!="enum"))
#*----------*##skipMutable($node.memberFieldMapList)
        }
#*--------*##else     
#*----------*##if($node.constructKind=="union")
        $node.unionDiscriminatorMap.nativeTypeFQName disc;

#*------------*##if(($node.unionDiscriminatorMap.typeKind=="user")
                    ||($node.unionDiscriminatorMap.typeKind=="enum"))   
        if (!${node.unionDiscriminatorMap.nativeTypeFQName}Plugin_deserialize_sample(
            endpoint_data,
            &disc,
            stream, 
            RTI_FALSE, RTI_TRUE, 
            endpoint_plugin_qos)) {
                return RTI_FALSE;
        }
#*------------*##else
        if (!${node.unionDiscriminatorMap.elementDeserializeMethod}(
            stream, &disc)) {
                return RTI_FALSE;
        }

#*------------*##end   
 
        switch(disc) {
#*----------*##end 
   
#*----------*##skip($node.memberFieldMapList)
#*----------*##if($node.constructKind=="union")
#*------*##if($node.needsDefaultCase.equals("true"))
        default: 
        {
            /* 
             * Prevents compiler warnings when discriminator is an enum
             * and unionType does not specify all enumeration members.
             */ 
        }
#*------*##end
        }
#*----------*##end
#*--------*##end
#*--------*##end
    }

#*------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType") 
                    && ($node.extensibility=="EXTENSIBLE_EXTENSIBILITY"))
    done = RTI_TRUE;
#*------*##if($node.memberCount == 0)
    goto fin;  /* To avoid unused label warning */
#*------*##end
fin:
    if (done != RTI_TRUE && 
        RTICdrStream_getRemainder(stream) >=
           RTI_CDR_PARAMETER_HEADER_ALIGNMENT) {
        return RTI_FALSE;   
    }
#*------*##end
    if(skip_encapsulation) {
        RTICdrStream_restoreAlignment(stream,rti_position);
    }

    return RTI_TRUE;
#*--*##end
}
#*--*##end #* $node.skipTypePluginCodeGen *#

#*-****************************************************************-*#

#*--*##if (!$node.skipTypePluginCodeGen)
unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size_ex(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool * overflow,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
#*—————-*##if($node.isMetpType)
    RTIBool metp = RTI_FALSE;
#*—————-*##end
#*--*##if ($node.languageBinding.equals("FLAT_DATA") 
        && !$node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    RTIOsapiUtility_unusedParameter(overflow);
#*--*##end
#if($node.xcdr1_maxSize)
return $node.xcdr1_maxSize;
#else
#*--*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp") && $node.isMetpType)
    unsigned int initial_alignment = current_alignment;
    unsigned int encapsulation_size = current_alignment;
    #*--------*##getEncapsulation ($node "false")
    current_alignment += METypePlugin_get_serialized_sample_max_size(
                    endpoint_data,
                    RTI_FALSE,
                    encapsulation_id,
                    current_alignment,
                    &metp);
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
    if (!metp) {
    #*--------*##flatPluginGetSerializedSampleMaxSizeBody ($node)
    }
    return  current_alignment - initial_alignment;
#*--*##elseif ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
#flatPluginGetSerializedSampleMaxSizeBody($node)
#*--*##elseif ($node.interpreted=="true")
#*----*##if($node.isMetpType)
    unsigned int initial_alignment = current_alignment;
    unsigned int encapsulation_size = current_alignment;
    #*--------*##getEncapsulation ($node "false")
    current_alignment += METypePlugin_get_serialized_sample_max_size(
                    endpoint_data,
                    include_encapsulation,
                    encapsulation_id,
                    current_alignment,
                    &metp);
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
    if (metp) {
        return current_alignment - initial_alignment;
    } else {
      current_alignment = initial_alignment;    
#*----*##end
    return PRESTypePlugin_interpretedGetSerializedSampleMaxSize(
    	endpoint_data,
    	overflow,
   	 	include_encapsulation,
    	encapsulation_id,
    	current_alignment);
#*--*##if($node.isMetpType)
    }
#*--*##end
#*--*##else ## not interpreted
#*----*##if($node.hasUnboundedMember && $envMap.unboundedSupport)
    if (endpoint_data) {} /* To avoid warnings */
    if (include_encapsulation) {}
    if (encapsulation_id) {}
    if (current_alignment) {}
    
    if (overflow != NULL) {
        *overflow = RTI_TRUE;
    }
    
    return RTI_CDR_MAX_SERIALIZED_SIZE;
#*----*##else

#*------*##if($node.constructKind=="union")
    unsigned int union_max_size_serialized = 0;
#*------*##end

    unsigned int initial_alignment = current_alignment;
    unsigned int encapsulation_size = current_alignment;
 
#*------*##if(!$node.baseTypeFQName && !$node.hasNonBasicMember)  
    if (endpoint_data) {} /* To avoid warnings */ 
    if (overflow) {} /* To avoid warnings */
#*------*##end   
#*--------*##getEncapsulation ($node "false")
#*———————-*##if($node.isMetpType)
        current_alignment += METypePlugin_get_serialized_sample_max_size(
                    endpoint_data,
                    include_encapsulation,
                    encapsulation_id,
                    current_alignment,
                    &metp);
	if (!metp) {
#*--------*##end
#*------*##if($node.constructKind=="enum")
    current_alignment += RTICdrType_getEnumMaxSizeSerialized(current_alignment);
#*------*##else

#*--------*##if(${node.baseTypeFQName})  
    current_alignment += ${node.baseTypeFQName}Plugin_get_serialized_sample_max_size_ex(
                              endpoint_data,overflow,RTI_FALSE,encapsulation_id,current_alignment);
#*--------*##end
    
#*--------*##if($node.constructKind=="union")
#*----------*##alignmentMaxSizeExUnion($node) 
#*--------*##else
#*----------*##alignmentMaxSizeEx($node) 
#*--------*##end    
#*------*##end

#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    /* Sentinel */

#*--------*##if($node.constructKind=="union")
    union_max_size_serialized += RTICdrStream_getExtendedParameterHeaderMaxSizeSerialized(union_max_size_serialized);
#*--------*##else
    current_alignment += RTICdrStream_getExtendedParameterHeaderMaxSizeSerialized(current_alignment);
#*--------*##end
#*------*##end
#*--------*##if($node.isMetpType)
}
#*--------*##end
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
    return #if($node.constructKind=="union")union_max_size_serialized +#*
----------*##end current_alignment - initial_alignment;
#*----*##end
#*--*##end
#end
}
#*--*##end #* $node.skipTypePluginCodeGen *#

#*-****************************************************************-*#


#*------*##if($node.constructKind=="enum")

unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
    unsigned int initial_alignment = current_alignment;

    current_alignment += #getSerializedSampleMaxSizeExFncName($node)(
        endpoint_data,
        NULL,
        include_encapsulation,
        encapsulation_id, current_alignment);

    return current_alignment - initial_alignment;
}

#*--*##if (!$node.skipTypePluginCodeGen)
unsigned int ${node.nativeFQNameInModule}Plugin_get_serialized_sample_min_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
#if($node.xcdr1_minSize)
return $node.xcdr1_minSize;
#else
    unsigned int initial_alignment = current_alignment;

    current_alignment += ${node.nativeFQName}Plugin_get_serialized_sample_max_size(
        endpoint_data,include_encapsulation,
        encapsulation_id, current_alignment);

    return current_alignment - initial_alignment;
#end    
}
#*--*##end #* $node.skipTypePluginCodeGen *#

#*------*##else

## Do not generate any type-plugin functions for flat-data alias
#*--*##if (!$node.languageBinding.equals("FLAT_DATA") || $node.constructKind!="alias")
unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
    unsigned int size;
    RTIBool overflow = RTI_FALSE;
    
    size = #getSerializedSampleMaxSizeExFncName($node)(
            endpoint_data,&overflow,include_encapsulation,encapsulation_id,current_alignment);
    
    if (overflow) {
        size = RTI_CDR_MAX_SERIALIZED_SIZE;
    }
    
    return size;
}

#*----*##if ($userVarList.testSupport && $node.isAggregationType)
unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size_test_only(
        RTIBool include_encapsulation,
        RTIEncapsulationId encapsulation_id,
        unsigned int current_alignment)
{
#*------*##createEndpointData($node)

    return ${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
            (PRESTypePluginEndpointData) &epd,
            include_encapsulation,
            encapsulation_id,
            current_alignment);
}
#*----*##end #* $userVarList.testSupport && $node.isAggregationType *#
#*--*##end #* !$node.languageBinding.equals("FLAT_DATA") || $node.constructKind!="alias" *#

#*--*##if (!$node.skipTypePluginCodeGen)
unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_min_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{

#if($node.xcdr1_minSize)
return $node.xcdr1_minSize;
#else
#*--*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp") && !$node.isMetpType)
#flatPluginGetSerializedSampleMinSizeBody($node)
#*--*##elseif ($node.interpreted=="true")
#*----*##if($node.isMetpType)
    RTIBool metp = RTI_FALSE;
    unsigned int initial_alignment = current_alignment;
    unsigned int encapsulation_size = current_alignment;
#*----*##getEncapsulation ($node "false")
    current_alignment += METypePlugin_get_serialized_sample_min_size(
                    endpoint_data,
                    include_encapsulation,
                    encapsulation_id,
                    current_alignment,
                    &metp);
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
    if (metp) {
        return current_alignment - initial_alignment;
    } else {
        current_alignment = initial_alignment;
#*----*##end 
	return PRESTypePlugin_interpretedGetSerializedSampleMinSize(
        	endpoint_data,
        	include_encapsulation,
        	encapsulation_id,
        	current_alignment);
#*----*##if($node.isMetpType)
    }
#*----*##end
#*--*##else ## not interpreted
#*--------*##if($node.isMetpType)
    RTIBool metp = RTI_FALSE;
#*--------*##end
#*--------*##if(${node.constructKind}=="union")  
    unsigned int union_min_size_serialized = 0xffffffff;
#*--------*##end

    unsigned int initial_alignment = current_alignment;
    unsigned int encapsulation_size = current_alignment;
 
#*--------*##if(!$node.baseTypeFQName)  
    if (endpoint_data) {} /* To avoid warnings */ 
#*--------*##end   
#*--------*##getEncapsulation ($node "false")
#*--------*##if(${node.baseTypeFQName})  
    current_alignment += ${node.baseTypeFQName}Plugin_get_serialized_sample_min_size(
                              endpoint_data,RTI_FALSE,encapsulation_id,current_alignment);
#*--------*##end
#*--------*##if($node.isMetpType)
        current_alignment += METypePlugin_get_serialized_sample_min_size(
                    endpoint_data,
                    include_encapsulation,
                    encapsulation_id,
                    current_alignment,
                    &metp);
    if (!metp) {
#*--------*##end
#*--------*##if($node.constructKind=="union")
#*----------*##alignmentMinSizeUnion($node) 
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    /* Sentinel */   
    union_min_size_serialized += RTICdrStream_getParameterHeaderMaxSizeSerialized(union_min_size_serialized);
#*----------*##end 
#*--------*##else
#*----------*##alignmentMinSize($node)
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    /* Sentinel */   
    current_alignment += RTICdrStream_getParameterHeaderMaxSizeSerialized(current_alignment);
#*----------*##end 
#*--------*##end
#*--------*##if($node.isMetpType)
}
#*--------*##end
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
    return #if($node.constructKind=="union")#*
--------*# union_min_size_serialized +#end current_alignment - initial_alignment;
#*--*##end
#end
}

#*----*##if ($userVarList.testSupport && $node.isAggregationType)
unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_min_size_test_only(
        RTIBool include_encapsulation,
        RTIEncapsulationId encapsulation_id,
        unsigned int current_alignment)
{
#*------*##createEndpointData($node)

    return ${node.nativeFQNameInModule}Plugin_get_serialized_sample_min_size(
        (PRESTypePluginEndpointData) &epd,
        include_encapsulation,
        encapsulation_id,
        current_alignment);
}
#*----*##end #* $userVarList.testSupport && $node.isAggregationType *#
#*--*##end #* $node.skipTypePluginCodeGen *#

#*--------*##end
#*-****************************************************************-*#

#*--*##if (!$node.skipTypePluginCodeGen)
/* Returns the size of the sample in its serialized form (in bytes).
 * It can also be an estimation in excess of the real buffer needed 
 * during a call to the serialize() function.
 * The value reported does not have to include the space for the
 * encapsulation flags.
 */
unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_sample_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment,
    const ${node.nativeFQNameInModule} * sample) 
{
  

#*--*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp") && !$node.isMetpType)
#flatPluginGetSerializedSampleSizeBody($node)
#*--*##elseif ($node.interpreted=="true")
#*----*##if($node.isMetpType) 
    RTIBool metp = RTI_FALSE;
    unsigned int encapsulation_size = current_alignment;
    unsigned int initial_alignment = current_alignment;
#*----*##getEncapsulation ($node, "true") 
    current_alignment += METypePlugin_get_serialized_sample_size(
                endpoint_data,
                include_encapsulation,
                encapsulation_id,
                current_alignment,
                &metp);
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }    
    if (metp) {
        return current_alignment - initial_alignment;
    } else {
        current_alignment = initial_alignment;
#*------*##if($node.languageBinding.equals("FLAT_DATA"))
#*--------*##flatPluginGetSerializedSampleSizeBody($node)
#*------*##end
#*----*##end
	return PRESTypePlugin_interpretedGetSerializedSampleSize(
        	endpoint_data,
        	include_encapsulation,
        	encapsulation_id,
        	current_alignment,
        	sample);
#*----*##if($node.isMetpType)
    }
#*----*##end        	
#*--*##else ## not interpreted
#*------*##if($node.constructKind=="enum")

    unsigned int initial_alignment = current_alignment;
  
    if (sample==NULL) {
        return 0;
    }

    current_alignment += ${node.nativeFQName}Plugin_get_serialized_sample_max_size(
        endpoint_data,include_encapsulation,
        encapsulation_id,
        PRESTypePluginDefaultEndpointData_getAlignment(
                    endpoint_data,
                    current_alignment));

    
#*------*##else
#*------*##if($node.isMetpType)
      RTIBool metp = RTI_FALSE;
#*------*##end 
    unsigned int initial_alignment = current_alignment;

    unsigned int encapsulation_size = current_alignment;
    struct PRESTypePluginDefaultEndpointData epd;   
 
#*------*##if(!$node.baseTypeFQName)  
    if (sample==NULL) {
        return 0;
    }
#*--------*##end
    if (endpoint_data == NULL) {
        endpoint_data = (PRESTypePluginEndpointData) &epd;
        PRESTypePluginDefaultEndpointData_setBaseAlignment(
                endpoint_data,
                current_alignment);        
    }

#*--------*##getEncapsulation ($node, "true")  

#*--------*##if($node.isMetpType)
        current_alignment += METypePlugin_get_serialized_sample_size(
                    endpoint_data,
                    include_encapsulation,
                    encapsulation_id,
                    current_alignment,
                    &metp);
    if (!metp) {
#*--------*##end
#*--------*##if(${node.baseTypeFQName})  
    current_alignment += ${node.baseTypeFQName}Plugin_get_serialized_sample_size(endpoint_data,RTI_FALSE,encapsulation_id,current_alignment,(const ${node.baseTypeFQName}*)sample);   
#*--------*##end
#*--------*##if($node.constructKind=="union")
#*----------*##alignmentSampleUnion($node)   
#*--------*##else
#*----------*##alignmentSample($node) 
#*--------*##end      
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    /* Sentinel */   
    current_alignment += RTICdrStream_getParameterHeaderMaxSizeSerialized(
            PRESTypePluginDefaultEndpointData_getAlignment(
                    endpoint_data,
                    current_alignment));
    PRESTypePluginDefaultEndpointData_setBaseAlignment(
                endpoint_data,
                current_alignment);                
#*--------*##end
#*--------*##if($node.isMetpType)
}
#*--------*##end

    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
#*------*##end
    return current_alignment - initial_alignment;
#*--*##end
}
#*--*##end #* $node.skipTypePluginCodeGen *#


/* --------------------------------------------------------------------------------------
    Key Management functions:
 * -------------------------------------------------------------------------------------- */

#*------*##if($node.constructKind!="enum" && 
        (!$node.languageBinding.equals("FLAT_DATA") || $node.constructKind!="alias"))
PRESTypePluginKeyKind 
${node.nativeFQNameInModule}Plugin_get_key_kind(void)
{
#*--------*##if($node.hasKey || $node.hasKeyBaseType)
    return PRES_TYPEPLUGIN_USER_KEY;
#*--------*##else    
    return PRES_TYPEPLUGIN_NO_KEY;
#*--------*##end     
}
#*------*##end

#*--*##if (!$node.skipTypePluginCodeGen)
RTIBool 
${node.nativeFQNameInModule}Plugin_serialize_key_for_keyhash(
    PRESTypePluginEndpointData endpoint_data,
    const ${node.nativeFQNameInModule} *sample, 
    struct RTICdrStream *stream,    
    RTIEncapsulationId encapsulation_id,
    void *endpoint_plugin_qos)
{
#*--*##if ($node.languageBinding.equals("FLAT_DATA"))
    #flatPluginSerializeKeyForKeyhashBody($node)
#*--*##elseif ($node.interpreted=="true")
    return PRESTypePlugin_interpretedSerializeKeyForKeyhash(
            endpoint_data,
            sample, 
            stream,    
            encapsulation_id,
            endpoint_plugin_qos);
#*--*##else
    return ${node.nativeFQName}Plugin_serialize_key(endpoint_data,
            sample, 
            stream,    
            RTI_FALSE,
            encapsulation_id,
            RTI_TRUE,
            endpoint_plugin_qos);
#*--*##end
}
#*--*##end

#*--*##if (!$node.skipTypePluginCodeGen)
RTIBool 
${node.nativeFQNameInModule}Plugin_serialize_key(
    PRESTypePluginEndpointData endpoint_data,
    const ${node.nativeFQNameInModule} *sample, 
    struct RTICdrStream *stream,    
    RTIBool serialize_encapsulation,
    RTIEncapsulationId encapsulation_id,
    RTIBool serialize_key,
    void *endpoint_plugin_qos)
{

#*--*##if ($node.interpreted=="true")
#*----*##if ($node.isMetpType)
    if (METypePlugin_validShmemEncapsulationId(encapsulation_id)) {
        encapsulation_id = DDS_DataRepresentationQosPolicy_getNativeEncapsulation(
                METypePlugin_getDataRepresentationId(endpoint_data));
    }
#*----*##end
#*----*##if($node.languageBinding.equals("FLAT_DATA"))
    #flatPluginSerializeKeyBody($node)
#*----*##else
    return PRESTypePlugin_interpretedSerializeKey(
        	endpoint_data,
        	sample, 
        	stream,    
        	serialize_encapsulation,
        	encapsulation_id,
        	serialize_key,
        	endpoint_plugin_qos);
       	
#*----*##end
#*--*##else
#*------*##if($node.constructKind=="enum")
    return  ${node.nativeFQName}Plugin_serialize(
            endpoint_data, sample, stream, 
            serialize_encapsulation, encapsulation_id, 
            serialize_key, endpoint_plugin_qos);

#*------*##else
    char * rti_position = NULL;
#*--------*##if($node.isMetpType)
    RTIBool metp;
#*--------*##end
    RTIOsapiUtility_unusedParameter(endpoint_data);
    RTIOsapiUtility_unusedParameter(endpoint_plugin_qos);
#* If is an alias of nonbasic type or
   it has a key but it is not a complex member key and it does not have a key in the parent*#
#*--------*##if(($node.constructKind.equals("alias") && $node.firstMember.typeKind.equals("builtin"))
                || ($node.hasKey && !$node.hasNonBasicKeyMember && !$node.hasKeyBaseType))
                
#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
            && ($node.hasKeyBaseType || $node.hasKey))
    if (endpoint_data == NULL) {
        return RTI_FALSE;
    }
#*----------*##end
#*--------*##end  
    
#*--------*##serializeEncapsulation ($node)

    if(serialize_key) {
    


#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
            && ($node.hasKeyBaseType || $node.hasKey))
        { 
            RTIBool ignoreListEndId = RTI_FALSE;
#*------------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") && $node.hasKey)
            DDS_UnsignedLong memberId = 0;
            char *memberLengthPosition = NULL;
            RTIBool extended=RTI_FALSE;
#*------------*##end
#*------------*##if($node.hasKey)           
            struct RTICdrStreamState state;
#*------------*##end            
    
            if (RTICdrStream_isDirty(stream)) {
                ignoreListEndId = stream->_xTypesState.skipListEndId; 
            } else {
                /* Top level */
                RTICdrStream_setDirtyBit(stream,RTI_TRUE);

#*------------*##if ($envMap.mutExtCode)
                stream->_xTypesState.useExtendedId = RTI_TRUE;
#*------------*##else
                if (PRESTypePluginDefaultEndpointData_getMaxSizeSerializedSample(endpoint_data) > 65535) {
                    stream->_xTypesState.useExtendedId = RTI_TRUE;
                } else {
                    stream->_xTypesState.useExtendedId = RTI_FALSE;
                }
#*------------*##end
            }

#*------------*##if(!$node.hasKeyBaseType || $envMap.serializeSentinelOnBase)
            stream->_xTypesState.skipListEndId = RTI_FALSE;
#*------------*##end  
#*----------*##end  

#*------------*##if($node.hasKeyBaseType)  
#*--------------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
#*----------------*##if(!$envMap.serializeSentinelOnBase)
            stream->_xTypesState.skipListEndId = RTI_TRUE;
#*----------------*##else
            stream->_xTypesState.skipListEndId = RTI_FALSE;
#*----------------*##end
#*--------------*##end
		    if (!${node.baseTypeFQName}Plugin_serialize_key(endpoint_data, 
		             (const ${node.baseTypeFQName}*)sample, stream, RTI_FALSE, 
		             encapsulation_id,RTI_TRUE, endpoint_plugin_qos)) {
		        return RTI_FALSE;
		    }
#*--------------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&
                           !$envMap.serializeSentinelOnBase)
            stream->_xTypesState.skipListEndId = RTI_FALSE;
#*--------------*##end
#*------------*##end

#*--------*##serialize_key($node)
#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
                  && ($node.hasKeyBaseType || $node.hasKey))
                  #serializeEndMutable()
        }
#*----------*##end     
       
    }

    if(serialize_encapsulation) {
        RTICdrStream_restoreAlignment(stream,rti_position);
    }

    return RTI_TRUE;
#*------*##end    
#*--*##end
}
#*--*##end #* $node.skipTypePluginCodeGen *#

#*-****************************************************************-*#

#*--*##if (!$node.skipTypePluginCodeGen)
RTIBool ${node.nativeFQNameInModule}Plugin_deserialize_key_sample(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *sample, 
    struct RTICdrStream *stream,
    RTIBool deserialize_encapsulation,
    RTIBool deserialize_key,
    void *endpoint_plugin_qos)
{
#*--*##if ($node.languageBinding.equals("FLAT_DATA"))
        #flatPluginDeSerializeKeySampleBody($node)      
#*--*##elseif ($node.interpreted=="true")
	return PRESTypePlugin_interpretedDeserializeKey(
        	endpoint_data,
        	sample,
        	stream,
        	deserialize_encapsulation,
        	deserialize_key,
        	endpoint_plugin_qos);
#*--*##else
#*--*##if($envMap.allocateWithNew)
    try {
#*--*##end 

#*------*##if($node.constructKind=="enum")
    return  ${node.nativeFQName}Plugin_deserialize_sample(
            endpoint_data, sample, stream, deserialize_encapsulation, 
            deserialize_key, endpoint_plugin_qos);
#*------*##else
    char * rti_position = NULL;
#*-—*##if($node.isMetpType)
    RTIBool metp;
#*--*##end    

#*--*##if(!$node.hasKeyBaseType||!$node.baseTypeFQName) 
    if (endpoint_data) {} /* To avoid warnings */
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*--*##end    
    
#*--*##deserializeEncapsulation ($node)
    if (deserialize_key) {
#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&$node.hasKey )
        DDS_UnsignedLong memberId = 0;
        DDS_UnsignedLong length = 0;
        RTIBool mustUnderstand = RTI_FALSE;
        RTIBool end = RTI_FALSE;
        RTIBool extended;
#*------*##end

#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&
                   ($node.hasKey || $node.hasKeyBaseType))
        struct RTICdrStreamState state;
#*------*##end
    
#*--------*##if($node.hasKeyBaseType)  
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&
                       !$envMap.serializeSentinelOnBase)
    {
        char *begin = RTICdrStream_getCurrentPosition(stream);
        RTICdrStream_pushState(stream, &state, -1);
#*----------*##end
   
        if (!${node.baseTypeFQName}Plugin_deserialize_key_sample(endpoint_data,
                (${node.baseTypeFQName}*)sample,stream,RTI_FALSE,RTI_TRUE,endpoint_plugin_qos)) {
            return RTI_FALSE;
        }    

#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&
                       !$envMap.serializeSentinelOnBase)
        RTICdrStream_popState(
                stream, &state);
            RTICdrStream_setCurrentPosition(stream, begin);
    }     
#*----------*##end    
#*--------*##end        

#*--------*##deserialize_key_sample($node)
    }

    if(deserialize_encapsulation) {
        RTICdrStream_restoreAlignment(stream,rti_position);
    }

    return RTI_TRUE;
#*------*##end    

#*--*##if($envMap.allocateWithNew)
    } catch (const std::bad_alloc&) {
        return RTI_FALSE;
    }
#*--*##end 
#*--*##end 
}
#*--*##end #* $node.skipTypePluginCodeGen *#

#*-****************************************************************-*#
#*------*##if($node.isAggregationType) 
RTIBool ${node.nativeFQNameInModule}Plugin_deserialize_key(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} **sample, 
    RTIBool * drop_sample,
    struct RTICdrStream *stream,
    RTIBool deserialize_encapsulation,
    RTIBool deserialize_key,
    void *endpoint_plugin_qos)
{
    RTIBool result;
#*--------*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    void* return_loaned_buffer = 
            (*(char **)sample == RTICdrStream_getBuffer(stream)) ? 
                    *(void **)sample : NULL;        
#*--------*##end    
    if (drop_sample) {} /* To avoid warnings */
#*--------*##if($node.interpreted!="true")
    stream->_xTypesState.unassignable = RTI_FALSE;
#*--------*##end
#*--*##if($node.isMetpType)
    if (deserialize_key) {
        *sample = (${node.nativeFQNameInModule} *)
                METypePlugin_get_sample(endpoint_data);
    }
#*--*##elseif ($node.languageBinding.equals("FLAT_DATA"))    
    if (deserialize_key) {
#*----*##if(!($node.extensibility.equals("MUTABLE_EXTENSIBILITY")))
        *sample = (${node.nativeFQNameInModule} *)PRESTypePluginDefaultEndpointData_getFstSampleWithSize(
            endpoint_data, 
            RTI_XCDR_ENCAPSULATION_HEADER_SIZE
                + (int)(${node.nativeFQNameInModule}Offset::serialized_size(0)));
#*----*##else
      *sample = (${node.nativeFQNameInModule} *)PRESTypePluginDefaultEndpointData_getFstSampleWithSize(
            endpoint_data, 
            PRESTypePluginDefaultEndpointData_getMaxSizeSerializedSample(endpoint_data));
#*----*##end
    }
#*--*##end
#*--*##if ($node.languageBinding.equals("FLAT_DATA"))
    if (deserialize_encapsulation && deserialize_key) {
        RTIOsapiMemory_copy(
                (void *) *sample,
                RTICdrStream_getBuffer(stream),
                RTI_XCDR_ENCAPSULATION_HEADER_SIZE);
    } else if (deserialize_key) {
        RTIXCdrFlatSample_initializeEncapsulation(
                *reinterpret_cast<char **>(sample),
                RTICdrStream_getEncapsulationKind(stream));    
    }
#*--*##end
    result= #deserializeKeySampleFncName($node)(
        endpoint_data, (sample != NULL)?*sample:NULL, stream,
        deserialize_encapsulation, deserialize_key, endpoint_plugin_qos);
#*--------*##if($node.interpreted!="true")
    if (result) {
        if (stream->_xTypesState.unassignable) {
            result = RTI_FALSE;
        }
    }
#*--------*##end
#*----*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    if (return_loaned_buffer != NULL) {
        REDAFastBufferPool_returnBuffer(
                PRESTypePluginDefaultEndpointData_getFstSampleDataPool(
                        endpoint_data),
                RTICdrStream_getBuffer(stream));  
    }        
#*----*##end  
    return result;    
        
        
}
#*------*##end

#*-****************************************************************-*#

#*--*##if (!$node.skipTypePluginCodeGen)
unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_key_max_size_ex(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool * overflow,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
#if($node.xcdr1_keyMaxSize)
    RTIOsapiUtility_unusedParameter(endpoint_data);
    RTIOsapiUtility_unusedParameter(overflow);
    RTIOsapiUtility_unusedParameter(include_encapsulation);
    RTIOsapiUtility_unusedParameter(encapsulation_id);
    RTIOsapiUtility_unusedParameter(current_alignment);
    
    return $node.xcdr1_keyMaxSize;
#else
#*--*##if ($node.interpreted=="true")
    return PRESTypePlugin_interpretedGetSerializedKeyMaxSize(
        	endpoint_data,
        	overflow,
        	include_encapsulation,
        	encapsulation_id,
        	current_alignment);
#*--*##else
#if($node.hasUnboundedKeyMember && $envMap.unboundedSupport)
    RTIOsapiUtility_unusedParameter(endpoint_data);
    RTIOsapiUtility_unusedParameter(include_encapsulation);
    RTIOsapiUtility_unusedParameter(encapsulation_id);
    RTIOsapiUtility_unusedParameter(current_alignment);
    
    if (overflow != NULL) {
        *overflow = RTI_TRUE;
    }
    
    return RTI_CDR_MAX_SERIALIZED_SIZE;

#else
#*------*##if($node.constructKind=="enum")
    unsigned int initial_alignment = current_alignment;

    current_alignment +=  ${node.nativeFQName}Plugin_get_serialized_sample_max_size_ex(
        endpoint_data, overflow, include_encapsulation,
        encapsulation_id, current_alignment);

#*------*##else
    unsigned int initial_alignment = current_alignment;
    unsigned int encapsulation_size = current_alignment;
 
#if(!$node.hasKeyBaseType && !$node.hasNonBasicKeyMember)  
    RTIOsapiUtility_unusedParameter(endpoint_data);
    RTIOsapiUtility_unusedParameter(overflow);
#end
#*--------*##getEncapsulation ($node "false")

#*--------*##if($node.hasKeyBaseType)    
    current_alignment += ${node.baseTypeFQName}Plugin_get_serialized_key_max_size_ex(
        endpoint_data,
        overflow,
        RTI_FALSE, encapsulation_id,
        current_alignment);
#*--------*##else
    RTIOsapiUtility_unusedParameter(endpoint_data);
    RTIOsapiUtility_unusedParameter(overflow);
#*--------*##end

#*--------*##get_serialized_key_max_size($node) 
#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") && $node.hasKey)
    /* Sentinel */
    current_alignment += RTICdrStream_getExtendedParameterHeaderMaxSizeSerialized(current_alignment);
#*------*##end
       
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
#*------*##end
    return current_alignment - initial_alignment;
#*------*##end   
#*--*##end
#end
}
#*--*##end #* $node.skipTypePluginCodeGen *#


#*--*##if (!$node.skipTypePluginCodeGen)
unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_key_max_size_for_keyhash_ex(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool * overflow,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
#*--*##if ($node.interpreted=="true")
    return PRESTypePlugin_interpretedGetSerializedKeyMaxSizeForKeyhash(
        endpoint_data,
        overflow,
        encapsulation_id,
        current_alignment);
#*--*##else
    return ${node.nativeFQName}Plugin_get_serialized_key_max_size_ex(
        endpoint_data,
        overflow,
        RTI_FALSE,
        encapsulation_id,
        current_alignment);
#*--*##end
}

#*--*##end #* $node.skipTypePluginCodeGen *#

#*-****************************************************************-*#

#*------*##if($node.constructKind!="enum" && 
        (!$node.languageBinding.equals("FLAT_DATA") || $node.constructKind!="alias"))
unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_key_max_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
    unsigned int size;
    RTIBool overflow = RTI_FALSE;
#*--------*##if($node.isMetpType && $node.interpreted=="true")
    if (METypePlugin_validShmemEncapsulationId(encapsulation_id)) {
        encapsulation_id = DDS_DataRepresentationQosPolicy_getNativeEncapsulation(
                METypePlugin_getDataRepresentationId(endpoint_data));
    }
#*--------*##end
#*--------*##if ($node.languageBinding.equals("FLAT_DATA"))    
    size = PRESTypePlugin_interpretedGetSerializedKeyMaxSize(
            endpoint_data,&overflow,include_encapsulation,encapsulation_id,current_alignment);
#*--------*##else
    size = #getSerializedKeyMaxSizeExFncName($node)(
            endpoint_data,&overflow,include_encapsulation,encapsulation_id,current_alignment);
#*--------*##end    
    if (overflow) {
        size = RTI_CDR_MAX_SERIALIZED_SIZE;
    }
    
    return size;
}

unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_key_max_size_for_keyhash(
    PRESTypePluginEndpointData endpoint_data,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
    unsigned int size;
    RTIBool overflow = RTI_FALSE;
#*--*##if ($node.languageBinding.equals("FLAT_DATA"))
    size = PRESTypePlugin_interpretedGetSerializedKeyMaxSizeForKeyhash(
            endpoint_data,
            &overflow,
            encapsulation_id,
            current_alignment);
#*--*##else    
    size = #getSerializedKeyMaxSizeExForKeyhashFncName($node)(
            endpoint_data,
            &overflow,
            encapsulation_id,
            current_alignment);
#*--*##end    
    if (overflow) {
        size = RTI_CDR_MAX_SERIALIZED_SIZE;
    }
    
    return size;
}
#end

#*-****************************************************************-*#

#*--*##if (!$node.skipTypePluginCodeGen)
RTIBool 
${node.nativeFQNameInModule}Plugin_serialized_sample_to_key(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *sample,
    struct RTICdrStream *stream, 
    RTIBool deserialize_encapsulation,  
    RTIBool deserialize_key, 
    void *endpoint_plugin_qos)
{
#*--*##if ($node.interpreted=="true")
	return PRESTypePlugin_interpretedSerializedSampleToKey(
        	endpoint_data,
        	sample,
        	stream, 
        	deserialize_encapsulation,  
        	deserialize_key, 
        	endpoint_plugin_qos);
        	
#*--*##else
#*------*##if($node.constructKind=="enum")

    return  ${node.nativeFQName}Plugin_deserialize_sample(
            endpoint_data, sample, stream, deserialize_encapsulation, 
            deserialize_key, endpoint_plugin_qos);

#*------*##else
    char * rti_position = NULL;

#*--------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType") 
                && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
      RTIBool done = RTI_FALSE;
      RTIBool error = RTI_FALSE;
#*--------*##end
#if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY") || $node.hasOptionalMember)&&($node.hasKey ||  $node.hasKeyBaseType))
    DDS_UnsignedLong memberId = 0;
    DDS_UnsignedLong length = 0;
    RTIBool extended;
    RTIBool mustUnderstand = RTI_FALSE;
    struct RTICdrStreamState state;
#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    RTIBool end = RTI_FALSE;
#*------*##end
#*--------*##end

#*--------*##if(($node.hasKey) 
               || ($node.constructKind=="alias") ||($node.hasKeyBaseType )) 

   if (endpoint_data) {} /* To avoid warnings */
   if (endpoint_plugin_qos) {} /* To avoid warnings */
   
#*--------*##end
#*----------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType") 
                 && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
   if (stream == NULL) {
       error = RTI_TRUE;
       goto fin;
   }
#*----------*##end
   if(deserialize_encapsulation) {
        if (!RTICdrStream_deserializeAndSetCdrEncapsulation(stream)) {
            return RTI_FALSE;
        }
        rti_position = RTICdrStream_resetAlignment(stream);
    }

    if (deserialize_key) {

#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
                  &&((${node.hasKeyBaseType})||($node.hasKey && $node.baseTypeFQName)))
              
  {
                    char *begin = RTICdrStream_getCurrentPosition(stream);
                    RTICdrStream_pushState(
                        stream, &state, -1);
#*----------*##end      
#*----------*##if(${node.hasKeyBaseType})       
        if (!${node.baseTypeFQName}Plugin_serialized_sample_to_key(endpoint_data,
                (${node.baseTypeFQName} *)sample,
                stream, RTI_FALSE, RTI_TRUE,
                endpoint_plugin_qos)) {
            return RTI_FALSE;
        }
#*----------*##elseif($node.hasKey && $node.baseTypeFQName) 
        if (!${node.baseTypeFQName}Plugin_skip(endpoint_data, stream,
                RTI_FALSE, RTI_TRUE,
                endpoint_plugin_qos)) {
            return RTI_FALSE;
        }
        
#*----------*##end  
#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
                  &&((${node.hasKeyBaseType})||($node.hasKey && $node.baseTypeFQName)))
        RTICdrStream_popState(
                        stream, &state);
                    RTICdrStream_setCurrentPosition(stream, begin);
                    }
#*----------*##end  
      
#*----------*##deserialize_key_and_skip($node)

     }
     
#*----------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType") 
                   && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
      done = RTI_TRUE;
fin:
    if(!error) {
        if (done != RTI_TRUE && 
            RTICdrStream_getRemainder(stream) >=
                RTI_CDR_PARAMETER_HEADER_ALIGNMENT) {
            return RTI_FALSE;   
        }
    } else {
        return RTI_FALSE;
    }       
#*----------*##end                

    if(deserialize_encapsulation) {
        RTICdrStream_restoreAlignment(stream,rti_position);
    }
                
                
    return RTI_TRUE;
#*--------*##end   
#*--*##end 
}
#*--*##end #* $node.skipTypePluginCodeGen *#
 
#*--------*##keyCode($node) ##The code with funtions relative to serialized/deserialized key is in this macro

#*------*##if($node.constructKind=="enum")
/* ----------------------------------------------------------------------------
    Support functions:
 * ---------------------------------------------------------------------------- */


void ${node.nativeFQNameInModule}PluginSupport_print_data(
    const ${node.nativeFQNameInModule} *sample,
    const char *description,
    unsigned int indent_level)
{
    if (description != NULL) {
        RTICdrType_printIndent(indent_level);
        RTILogParamString_printPlain("%s:\n", description);
    }

    if (sample == NULL) {
        RTICdrType_printIndent(indent_level+1);
        RTILogParamString_printPlain("NULL\n");
        return;
    }

    RTICdrType_printEnum((RTICdrEnum *)sample, "${node.nativeFQNameInModule}", indent_level + 1);
}

#*------*##end
#*-—————*##if($node.isMetpType)
void*
${node.nativeFQNameInModule}Plugin_get_sample_metp(
    PRESTypePluginEndpointData endpointData,
    void **handle)
{
    return PRESTypePluginDefaultEndpointData_getSample(endpointData, handle);
}

void
${node.nativeFQNameInModule}Plugin_return_sample_metp(
    PRESTypePluginEndpointData endpointData,
    void *sample, 
    void *handle)
{
#*--------*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp")) 
    if ((handle != NULL) &&
        (*(void **)handle == (void*)PRES_TYPE_PLUGIN_INVALID_REASSEMBLED_SAMPLE_ADDRESS)) {
        ${node.nativeFQNameInModule}Plugin_return_sample_flat_data(
            endpointData, sample, handle);
    } else {
#*--------*##end
        METypePlugin_return_sample(endpointData, sample, handle);
        /*
        * A NULL handle indicates that the sample did not come from the 
        * TypePlugin sample pool. Hence we do not return it to the pool.
        */
        if (handle != NULL) {
            PRESTypePluginDefaultEndpointData_returnSample(
                    endpointData,
                    sample,
                    handle);
        }
#*--------*##if ($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    }
#*--------*##end
}
#*-—————*##end

#*------*##if ($node.isAggregationType && $node.interpreted=="true")

#*--------*##if(!$userVarList.noEndpointBuild)
struct RTIXCdrInterpreterPrograms * ${node.nativeFQNameInModule}Plugin_get_programs(void)
{
#*----------*##if($envMap.language.equals("Cpp"))
    return ::rti::xcdr::get_cdr_serialization_programs<
	    ${node.nativeFQNameInModule}, 
    #if ($node.optimizationLevel == 0)
		false, false, false>();
    #else
      #if ($node.optimizationLevel == 1)
        true, false, false>();
      #else
        true, true, true>();
      #end
    #end
#*----------*##else
        struct RTIXCdrInterpreterProgramsGenProperty programProperty =
                RTIXCdrInterpreterProgramsGenProperty_INITIALIZER;
        struct RTIXCdrInterpreterPrograms *retPrograms = NULL;

        programProperty.generateWithOnlyKeyFields = RTI_XCDR_FALSE;
        #initializeProgramProperties($node)

        retPrograms =
                DDS_TypeCodeFactory_assert_programs_in_global_list(
                        DDS_TypeCodeFactory_get_instance(),
                        ${node.nativeFQNameInModule}_get_typecode(),
                        &programProperty,
                        RTI_XCDR_SER_PROGRAM
                            | RTI_XCDR_DESER_PROGRAM
                            | RTI_XCDR_GET_MAX_SER_SIZE_PROGRAM
#*----------*##if($userVarList.testSupport)
                            | RTI_XCDR_GET_MIN_SER_SIZE_PROGRAM
#*----------*##end
                            | RTI_XCDR_GET_SER_SIZE_PROGRAM);

    return retPrograms;
#*----------*##end ## C/Cpp
}
#*--------*##end
#*------*##end

/* ------------------------------------------------------------------------
 * Plug-in Installation Methods
 * ------------------------------------------------------------------------ */
#*------*##if (($node.isAggregationType)
                 && ($node.topLevel=="true"))                  
struct PRESTypePlugin *${node.nativeFQNameInModule}Plugin_new(void) 
{ 
    struct PRESTypePlugin *plugin = NULL;
    const struct PRESTypePluginVersion PLUGIN_VERSION = 
        PRES_TYPE_PLUGIN_VERSION_2_0;
        
    RTIOsapiHeap_allocateStructure(
        &plugin, struct PRESTypePlugin);
        
    if (plugin == NULL) {
       return NULL;
    }

    plugin->version = PLUGIN_VERSION;

    /* set up parent's function pointers */
    plugin->onParticipantAttached =
        (PRESTypePluginOnParticipantAttachedCallback)
        ${node.nativeFQName}Plugin_on_participant_attached;
    plugin->onParticipantDetached =
        (PRESTypePluginOnParticipantDetachedCallback)
        ${node.nativeFQName}Plugin_on_participant_detached;
    plugin->onEndpointAttached =
        (PRESTypePluginOnEndpointAttachedCallback)
        ${node.nativeFQName}Plugin_on_endpoint_attached;
    plugin->onEndpointDetached =
        (PRESTypePluginOnEndpointDetachedCallback)
        ${node.nativeFQName}Plugin_on_endpoint_detached;

    plugin->copySampleFnc =
        (PRESTypePluginCopySampleFunction)
        ${node.nativeFQName}Plugin_copy_sample;
    plugin->createSampleFnc =
        (PRESTypePluginCreateSampleFunction)
        ${node.nativeFQNameInModule}Plugin_create_sample;
    plugin->destroySampleFnc =
        (PRESTypePluginDestroySampleFunction)
        ${node.nativeFQNameInModule}Plugin_destroy_sample;
    plugin->finalizeOptionalMembersFnc =
        (PRESTypePluginFinalizeOptionalMembersFunction)
        ${node.nativeFQNameInModule}Plugin_finalize_optional_members;

    plugin->serializeFnc = 
        (PRESTypePluginSerializeFunction) #serializeFncName($node);
    plugin->deserializeFnc =
        (PRESTypePluginDeserializeFunction) #deserializeFncName($node);
    plugin->getSerializedSampleMaxSizeFnc =
        (PRESTypePluginGetSerializedSampleMaxSizeFunction)
        ${node.nativeFQName}Plugin_get_serialized_sample_max_size;
    plugin->getSerializedSampleMinSizeFnc =
        (PRESTypePluginGetSerializedSampleMinSizeFunction)
        #getSerializedSampleMinSizeFncName($node);
#*--------*##if($node.isMetpType || $node.languageBinding.equals("FLAT_DATA"))        
    plugin->getDeserializedSampleMaxSizeFnc = 
        (PRESTypePluginGetDeserializedSampleMaxSizeFunction)
        ${node.nativeFQNameInModule}Plugin_get_deserialized_sample_max_size;
#*--------*##else
    plugin->getDeserializedSampleMaxSizeFnc = NULL; 
#*--------*##end
#*--------*##if($node.isMetpType)
    plugin->getSampleFnc =
        (PRESTypePluginGetSampleFunction)
        ${node.nativeFQNameInModule}Plugin_get_sample_metp;
    plugin->returnSampleFnc =
        (PRESTypePluginReturnSampleFunction)
        ${node.nativeFQNameInModule}Plugin_return_sample_metp;
#*--------*##elseif($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    plugin->getSampleFnc =
        (PRESTypePluginGetSampleFunction)
        ${node.nativeFQNameInModule}Plugin_get_sample_flat_data;
    plugin->returnSampleFnc =
        (PRESTypePluginReturnSampleFunction)
        ${node.nativeFQNameInModule}Plugin_return_sample_flat_data;
#*--------*##else
    plugin->getSampleFnc =
        (PRESTypePluginGetSampleFunction)
        ${node.nativeFQNameInModule}Plugin_get_sample;
    plugin->returnSampleFnc =
        (PRESTypePluginReturnSampleFunction)
        ${node.nativeFQNameInModule}Plugin_return_sample;
#*--------*##end
    plugin->getKeyKindFnc =
        (PRESTypePluginGetKeyKindFunction)
        ${node.nativeFQName}Plugin_get_key_kind;
        
#*--------*##if($node.hasKey || $node.hasKeyBaseType)
    plugin->getSerializedKeyMaxSizeFnc =   
        (PRESTypePluginGetSerializedKeyMaxSizeFunction)
       ${node.nativeFQName}Plugin_get_serialized_key_max_size;
    plugin->serializeKeyFnc =
        (PRESTypePluginSerializeKeyFunction)
        #serializeKeyFncName($node);
    plugin->deserializeKeyFnc =
        (PRESTypePluginDeserializeKeyFunction)
        ${node.nativeFQName}Plugin_deserialize_key;
    plugin->deserializeKeySampleFnc =
        (PRESTypePluginDeserializeKeySampleFunction)
        #deserializeKeySampleFncName($node);

    plugin-> instanceToKeyHashFnc = 
        (PRESTypePluginInstanceToKeyHashFunction)
        #instanceToKeyHashFncName($node);
    plugin->serializedSampleToKeyHashFnc = 
        (PRESTypePluginSerializedSampleToKeyHashFunction)
        ${node.nativeFQName}Plugin_serialized_sample_to_keyhash;

    plugin->getKeyFnc =
        (PRESTypePluginGetKeyFunction)
       ${node.nativeFQNameInModule}Plugin_get_key;
    plugin->returnKeyFnc =
        (PRESTypePluginReturnKeyFunction)
        ${node.nativeFQNameInModule}Plugin_return_key;

    plugin->instanceToKeyFnc =
        (PRESTypePluginInstanceToKeyFunction)
       ${node.nativeFQName}Plugin_instance_to_key;
    plugin->keyToInstanceFnc =
        (PRESTypePluginKeyToInstanceFunction)
        ${node.nativeFQName}Plugin_key_to_instance;
    plugin->serializedKeyToKeyHashFnc = NULL; /* Not supported yet */
#*--------*##else
    /* These functions are only used for keyed types. As this is not a keyed
    type they are all set to NULL
    */
    plugin->serializeKeyFnc = NULL ;    
    plugin->deserializeKeyFnc = NULL;  
    plugin->getKeyFnc = NULL;
    plugin->returnKeyFnc = NULL;
    plugin->instanceToKeyFnc = NULL;
    plugin->keyToInstanceFnc = NULL;
    plugin->getSerializedKeyMaxSizeFnc = NULL;
    plugin->instanceToKeyHashFnc = NULL;
    plugin->serializedSampleToKeyHashFnc = NULL;
    plugin->serializedKeyToKeyHashFnc = NULL;    
#*--------*##end
${envMap.POUND_CHAR}ifdef NDDS_STANDALONE_TYPE
    plugin->typeCode = NULL; 
${envMap.POUND_CHAR}else
    plugin->typeCode =  (struct RTICdrTypeCode *)${node.nativeFQName}_get_typecode();
#*--------*##if($userVarList.noEndpointBuild)
    ${envMap.POUND_CHAR}define RTICdrTypeCode RTIXCdrTypeCode
#*--------*##end
${envMap.POUND_CHAR}endif
#*--------*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    plugin->languageKind = PRES_TYPEPLUGIN_FLATDATA_TYPE;
#*--------*##elseif($envMap.language.equals("Cpp") && ($envMap.stringIsObject || $envMap.generateCppVirtualDestructor))
    plugin->languageKind = PRES_TYPEPLUGIN_NON_DDS_TYPE;
#*--------*##elseif($envMap.language.equals("Cpp"))
#*----------*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
    plugin->languageKind = PRES_TYPEPLUGIN_FLATDATA_TYPE;
#*----------*##else
    plugin->languageKind = PRES_TYPEPLUGIN_CPP_LANG;
#*----------*##end
#*--------*##else
    plugin->languageKind = PRES_TYPEPLUGIN_DDS_TYPE;
#*--------*##end 

    /* Serialized buffer */
#*--------*##if($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))    
    plugin->getBufferWithParams = 
        (NDDS_WriterHistory_Allocator_getBufferWithParams_fn)
        ${node.nativeFQNameInModule}Plugin_get_buffer_w_params;
    plugin->returnBufferWithParams = 
        (NDDS_WriterHistory_Allocator_returnBufferWithParams_fn)
        ${node.nativeFQNameInModule}Plugin_return_buffer_w_params;
    plugin->getBuffer = NULL;
    plugin->returnBuffer = NULL;        
#*--------*##else
    plugin->getBuffer = 
        (PRESTypePluginGetBufferFunction)
        ${node.nativeFQNameInModule}Plugin_get_buffer;
    plugin->returnBuffer = 
        (PRESTypePluginReturnBufferFunction)
        ${node.nativeFQNameInModule}Plugin_return_buffer;
    plugin->getBufferWithParams = NULL;
    plugin->returnBufferWithParams = NULL;  
#*--------*##end
    plugin->getSerializedSampleSizeFnc =
        (PRESTypePluginGetSerializedSampleSizeFunction)
        #getSerializedSampleSizeFncName($node);

#*--------*##if(($node.languageBinding.equals("FLAT_DATA") && $envMap.language.equals("Cpp"))
                  && (!$node.isMetpType))
    /* writer loaned sample pool */
    plugin->getWriterLoanedSampleFnc = 
        (PRESTypePluginGetWriterLoanedSampleFunction)
        ${node.nativeFQNameInModule}Plugin_get_writer_loaned_sample;
    plugin->returnWriterLoanedSampleFnc = 
        (PRESTypePluginReturnWriterLoanedSampleFunction)
        ${node.nativeFQNameInModule}Plugin_return_writer_loaned_sample;
    plugin->returnWriterLoanedSampleFromCookieFnc = 
        (PRESTypePluginReturnWriterLoanedSampleFromCookieFunction)
        ${node.nativeFQNameInModule}Plugin_return_writer_loaned_sample_from_cookie;
    plugin->validateWriterLoanedSampleFnc = 
        (PRESTypePluginValidateWriterLoanedSampleFunction)
        ${node.nativeFQNameInModule}Plugin_validate_writer_loaned_sample;
    plugin->setWriterLoanedSampleSerializedStateFnc = 
        (PRESTypePluginSetWriterLoanedSampleSerializedStateFunction)
        ${node.nativeFQNameInModule}Plugin_set_writer_loaned_sample_serialized_state;
#*--------*##else
    plugin->getWriterLoanedSampleFnc = NULL; 
    plugin->returnWriterLoanedSampleFnc = NULL;
    plugin->returnWriterLoanedSampleFromCookieFnc = NULL;
    plugin->validateWriterLoanedSampleFnc = NULL;
    plugin->setWriterLoanedSampleSerializedStateFnc = NULL;
#*--------*##end

    plugin->endpointTypeName = ${node.nativeFQNameInModule}TYPENAME;
#*--------*##if($node.isMetpType)
    plugin->isMetpType = RTI_TRUE;
#*--------*##else
    plugin->isMetpType = RTI_FALSE;
#*--------*##end
    return plugin;
}

void
${node.nativeFQNameInModule}Plugin_delete(struct PRESTypePlugin *plugin)
{
    RTIOsapiHeap_freeStructure(plugin);
} 
#*------*##end
#*----*##end
#*--*##end 
${envMap.POUND_CHAR}undef RTI_CDR_CURRENT_SUBMODULE 
